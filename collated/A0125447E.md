# A0125447E
###### src\katnote\ui\CommandBarController.java
``` java
package katnote.ui;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

public class CommandBarController {
    private static final String NORMAL_STYLE = "-fx-text-fill: black;";
    private static final String ERROR_STYLE = "-fx-text-fill: red;";
    private static final boolean IS_ERROR = true;
    private static final boolean IS_NOT_ERROR = false;

    private GraphicalUserInterface mainUI;

    @FXML
    private TextField commandBar;
    @FXML
    private Label responseLabel;

    @FXML
    void onKeyPress(KeyEvent event) {
        if (event.getCode() == KeyCode.ENTER) {
            if (!commandBar.getText().isEmpty()) {
                mainUI.handleCommandInput(commandBar.getText());
                commandBar.clear();
            }
        }
    }

    @FXML
    void onInputClicked(MouseEvent event) {
        if (!commandBar.getText().isEmpty()) {
            mainUI.handleCommandInput(commandBar.getText());
            commandBar.clear();
        }
    }

    public void setMainUI(GraphicalUserInterface mainUI) {
        this.mainUI = mainUI;
    }

    public void setResponseText(String response) {
        setResponseText(response, IS_NOT_ERROR);
    }

    public void setErrorText(String response) {
        setResponseText(response, IS_ERROR);
    }

    public void setResponseText(String response, boolean isError) {
        setResponseErrorState(isError);
        responseLabel.setText(response);
    }

    private void setResponseErrorState(boolean isError) {
        if (isError) {
            responseLabel.setStyle(ERROR_STYLE);
        } else {
            responseLabel.setStyle(NORMAL_STYLE);
        }
    }

}
```
###### src\katnote\ui\GraphicalUserInterface.java
``` java
package katnote.ui;

import katnote.KatNoteLogger;
import katnote.logic.Logic;
import katnote.logic.UIFeedback;
import katnote.logic.ViewState;
import katnote.task.Task;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Font;

public class GraphicalUserInterface extends Application {
    private static GraphicalUserInterface instance;
    private static final Logger log = KatNoteLogger.getLogger(GraphicalUserInterface.class.getName());
    private static final String ROOT_LAYOUT_FXML = "/katnote/resources/ui/RootLayout.fxml";

    private BorderPane rootLayout;
    private Stage primaryStage;
    private Logic logic;
    private TaskViewer taskViewer;
    private ArrayList<Task> displayedTaskList;
    private CommandBarController commandBarController;

    public ArrayList<Task> getDisplayedTaskList() {
        return displayedTaskList;
    }

    public void start(String[] args) {
        launch(args);
    }    
    
    public static GraphicalUserInterface getInstance(){
        if(instance == null){
            throw new NullPointerException("App not initialized");
        }
        return instance;
    }

    public CommandBarController getCommandController() {
        return commandBarController;
    }

    @Override
    public void start(Stage primaryStage) {
        instance = this;
        loadResources();
        initialize(primaryStage);

        initRootLayout();
        setUpTaskViewer();
    }

    private void initialize(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle("KatNote");
        try {
            logic = new Logic();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    private void loadResources() {
        log.log(Level.INFO, "loading resources");
        Font.loadFont(getClass().getResource("/katnote/resources/ui/font/sen/sen-extrabold.otf").toExternalForm(), 10);
        Font.loadFont(getClass().getResource("/katnote/resources/ui/font/sen/sen-bold.otf").toExternalForm(), 10);
    }

    public void initRootLayout() {
        log.log(Level.FINE, "initilizing rootLayout");
        try {
            // Load root layout from fxml file.
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource(ROOT_LAYOUT_FXML));
            rootLayout = (BorderPane) loader.load();
            commandBarController = loader.getController();
            commandBarController.setMainUI(this);

            // Show the scene containing the root layout.
            Scene scene = new Scene(rootLayout);
            primaryStage.setScene(scene);
            primaryStage.setResizable(false);
            primaryStage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void setUpTaskViewer() {
        log.log(Level.INFO, "setUpTaskViewer");
        taskViewer = new TaskViewer();
        rootLayout.setCenter(taskViewer);
        displayedTaskList = updateTaskViewer(logic.getInitialViewState(), false);
        logic.setViewMapping(displayedTaskList);
    }

    public ArrayList<Task> updateTaskViewer(ViewState viewState, boolean isSearch) {
        log.log(Level.INFO, "updateTaskViewer");
        TaskViewFormatter listFormat = new TaskViewFormatter(viewState, isSearch);
        taskViewer.loadTaskFormat(listFormat);
        return listFormat.getOrderedTaskList();
    }

    public void handleCommandInput(String inputText) {
        log.log(Level.FINE, "input recieved: " + inputText);
        UIFeedback feedback;
        try {
            feedback = logic.execute(inputText);
            commandBarController.setResponseText(feedback.getMessage(), feedback.isAnError());
            if (feedback.isAnExit()) {
                primaryStage.close();
            } else if (!feedback.isAnError()) {
                ViewState viewState = feedback.getViewState();
                if (viewState != null) {
                    displayedTaskList = updateTaskViewer(viewState, feedback.isASearch());
                    logic.setViewMapping(displayedTaskList);
                }
            }
        } catch (Exception e) {
            log.log(Level.WARNING, "Exception: " + e.getMessage());
            commandBarController.setErrorText(e.getMessage());
            e.printStackTrace();
        }

    }

}
```
###### src\katnote\ui\TaskDetailedRow.java
``` java
package katnote.ui;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import katnote.task.Task;
import katnote.task.TaskType;

public class TaskDetailedRow extends AnchorPane {

    private static final String CHECKMARK_CLASS_NAME = "check";
    private static final String NORMAL_TASK_DATE_FORMAT = "Due: %1s %2s";
    private static final String NORMAL_TASK_TIME_FORMAT = "Due: %1s";
    private static final String EVENT_DATE_TIME_FORMAT = "Start: %1s             End: %2s";
    private static final String DATE_TIME_PATTERN = "dd MMM yy hh:mm a";
    private static final String TIME_PATTERN = "hh:mm a";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskDetailedRow.fxml";
    private static final String DISPLAY_INDEX_STRING = "%d.";

    @FXML
    private Label taskDescriptionLabel;
    @FXML
    private Label dateTimeLabel;
    @FXML
    private Pane checkmarkPane;
    @FXML
    private Label viewIndexLabel;
    private Task task;
    private int index;
    private boolean isDateHidden;

    public TaskDetailedRow(Task task, int index) {
        this(task, index, false);
    }

    public TaskDetailedRow(Task task, int viewIndex, boolean isDateHidden) {
        loadFXML();
        this.task = task;
        this.index = viewIndex;
        this.isDateHidden = isDateHidden;

        setIndexProperty(viewIndex);    
        setDescriptionProperty();
        setDateTimeProperty();
        setCompletedProperty();
    }

    private void setIndexProperty(int viewIndex) {
        viewIndexLabel.setText(String.format(DISPLAY_INDEX_STRING, viewIndex));
    }

    private void setDescriptionProperty() {
        taskDescriptionLabel.setText(task.getTitle());
    }

    public String getDescription() {
        return taskDescriptionLabel.getText();
    }

    public String getDateString() {
        return dateTimeLabel.getText();
    }
    
    public String getIndexString() {
        return viewIndexLabel.getText();
    }

    private void setDateTimeProperty() {
        if (task.getTaskType() == TaskType.NORMAL) {
            LocalDateTime date = task.getEndDate();
            DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
            String dateString = date.format(dateFormat);
            DateTimeFormatter timeFormat = DateTimeFormatter.ofPattern(TIME_PATTERN);
            String timeString = date.format(timeFormat);
            String dateTime;
            if (isDateHidden) {
                dateTime = String.format(NORMAL_TASK_TIME_FORMAT, timeString);
            } else {
                dateTime = String.format(NORMAL_TASK_DATE_FORMAT, dateString, timeString);
            }
            dateTimeLabel.setText(dateTime);
        } else if (task.getTaskType() == TaskType.EVENT) {
            LocalDateTime startDate = task.getStartDate();
            LocalDateTime endDate = task.getEndDate();
            DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern(DATE_TIME_PATTERN);
            String startDateString = startDate.format(dateTimeFormat);
            String endDateString = endDate.format(dateTimeFormat);
            String dateTime = String.format(EVENT_DATE_TIME_FORMAT, startDateString, endDateString);
            dateTimeLabel.setText(dateTime);
        }
    }

    private void setCompletedProperty() {
        if (task.isCompleted()) {
            checkmarkPane.getStyleClass().add(CHECKMARK_CLASS_NAME);
        }
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```
###### src\katnote\ui\TaskRow.java
``` java
package katnote.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;

public class TaskRow extends AnchorPane {
    private static final String CHECKMARK_CLASS_NAME = "check";
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskRow.fxml";
    private static final String DISPLAY_INDEX_STRING = "%d.";

    @FXML
    private Label taskDescriptionLabel;

    @FXML
    private Label timeLabel;
    
    @FXML
    private Label viewIndexLabel;

    @FXML
    private Pane checkmarkPane;


    public TaskRow(int viewIndex, String taskDescription, boolean isDone) {
        loadFXML();
        setIndexProperty(viewIndex);        
        setTaskDescription(taskDescription);
        setCompletedProperty(isDone);
    }

    private void setIndexProperty(int viewIndex) {
        viewIndexLabel.setText(String.format(DISPLAY_INDEX_STRING, viewIndex));
    }

    public String getDescription() {
        return taskDescriptionLabel.getText();
    }

    private void setCompletedProperty(boolean isDone) {
        if (isDone) {
            checkmarkPane.getStyleClass().add(CHECKMARK_CLASS_NAME);
        }
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void setTaskDescription(String text) {
        taskDescriptionLabel.setText(text);
    }

}
```
###### src\katnote\ui\TaskViewer.java
``` java
package katnote.ui;

import java.io.IOException;
import java.util.ArrayList;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class TaskViewer extends AnchorPane {
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskViewer.fxml";

    @FXML
    private VBox taskViewGroupList;

    public TaskViewer() {
        loadFXML();
        taskViewGroupList.setFillWidth(true);
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void clearViewer() {
        taskViewGroupList.getChildren().clear();
    }

    public void loadTaskFormat(TaskViewFormatter listFormat) {
        clearViewer();
        updateTaskView(listFormat);
    }

    private void updateTaskView(TaskViewFormatter listFormat) {
        ArrayList<TaskViewGroup> viewList = listFormat.getFormattedViewGroupList();

        for (TaskViewGroup viewGroup : viewList) {
            taskViewGroupList.getChildren().add(viewGroup);
        }
    }

}
```
###### src\katnote\ui\TaskViewFormatter.java
``` java
package katnote.ui;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Locale;
import java.util.Queue;

import katnote.logic.ViewState;
import katnote.task.Task;

public class TaskViewFormatter {

    private static final int FRONT_INDEX = 0;
    private static final int NUMBER_OF_DAYS_A_WEEK = 7;
    private static final String GROUP_TITLE_OVERDUE = "Overdue";
    private static final String GROUP_TITLE_TODAY = "Today";
    private static final String GROUP_TITLE_TOMORROW = "Tomorrow";
    private static final String GROUP_TITLE_SEARCH_RESULT = "Search Result";
    private static final String GROUP_TITLE_FLOATING_TASKS = "Task to do";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(DATE_PATTERN);

    private ArrayList<TaskViewGroup> _viewList = new ArrayList<TaskViewGroup>();
    private ArrayList<Task> _viewOrderedTaskList = new ArrayList<Task>();
    private int index = 1;

    public TaskViewFormatter(ViewState viewState, boolean isSearch) {
        ArrayList<Task> floatingTasks = viewState.getFloatingTasks();
        ArrayList<Task> normalTasks = viewState.getNormalTasks();
        ArrayList<Task> events = viewState.getEventTasks();
        if(isSearch){
            processSearchListing(floatingTasks, normalTasks, events);
        } else {
            processFloatingTask(floatingTasks);
            processNormalTasksAndEvents(normalTasks, events);            
        }
    }

    /**
     * Retrieves the ordered task list that is in the same order as the task
     * displayed
     * 
     * @return the list of task in a view-dependent order
     */
    public ArrayList<Task> getOrderedTaskList() {
        return _viewOrderedTaskList;
    }

    /**
     * Retrieves the formatted list for GUI
     * 
     * @return the list of formatted UI components
     */
    public ArrayList<TaskViewGroup> getFormattedViewGroupList() {
        return _viewList;
    }

    private void processSearchListing(ArrayList<Task> floatingTasks, ArrayList<Task> normalTasksList, ArrayList<Task> eventList) {
        processFloatingTask(floatingTasks);
        ArrayList<Task> combinedList = combineNormalAndEventsOrdered(normalTasksList, eventList);
        if (combinedList.isEmpty()) {
            return;
        }
        _viewList.add(createTaskGroupDetailed(GROUP_TITLE_SEARCH_RESULT, combinedList, false));
    }

    private void processForOverdue(Queue<Task> normalTasksQueue) {
        ArrayList<Task> overdueList = extractTaskDueBeforeThisDate(normalTasksQueue, LocalDate.now());
        if (overdueList.isEmpty()) {
            return;
        }
        TaskViewGroup taskGroupOverDue = createTaskOverdueGroup(overdueList);
        _viewList.add(taskGroupOverDue);

    }

    private void processForTheWeek(Queue<Task> normalTasksQueue, ArrayList<Task> eventList) {
        ArrayList<Task> remainingList;
        ArrayList<Task> eventRemainingWeekList;

        for (int i = 0; i <= NUMBER_OF_DAYS_A_WEEK; i++) {
            LocalDate dayDue = LocalDate.now().plusDays(i);
            remainingList = extractTaskDueThisDate(normalTasksQueue, dayDue);
            eventRemainingWeekList = extractEventsHappeningThisDate(eventList, dayDue, false);
            if (remainingList.isEmpty() && eventRemainingWeekList.isEmpty()) {
                continue;
            }

            ArrayList<Task> combinedList = combineNormalAndEventsOrdered(remainingList, eventRemainingWeekList);

            if (i == 0) {
                TaskViewGroup taskGroupForToday = createTaskTodayGroup(combinedList);
                _viewList.add(taskGroupForToday);
            } else if (i == 1) {
                TaskViewGroup taskGroupForTomorrow = createTaskTomorrowGroup(combinedList);
                _viewList.add(taskGroupForTomorrow);
            } else {
                String dayOfWeekString = getDayString(dayDue.getDayOfWeek());
                dayOfWeekString += "      " + dayDue.format(DATE_FORMAT);
                _viewList.add(createTaskGroupDetailed(dayOfWeekString, combinedList, true));
            }
        }
    }

    private void processRemainingTask(Queue<Task> normalTasksQueue, ArrayList<Task> eventCopy) {
        LocalDate date = LocalDate.now();
        Queue<Task> eventQueue = copyTasksIntoLinkedList(eventCopy);
        while (!normalTasksQueue.isEmpty()) {
            boolean isEventSelected = false;
            Task normalTask = normalTasksQueue.peek();
            Task event = (eventCopy.size() > 0) ? eventCopy.get(0) : null;
            LocalDate eventDateStart = (event != null) ? event.getStartDate().toLocalDate() : null;
            date = normalTask.getEndDate().toLocalDate();
            if(eventDateStart != null && date.isAfter(eventDateStart)){
                date = eventDateStart;
                isEventSelected = true;
            }
            ArrayList<Task> normalTaskListThisDate = extractTaskDueThisDate(normalTasksQueue, date);
            ArrayList<Task> eventListThisDate = extractEventsHappeningThisDate(eventCopy, date, isEventSelected);
            ArrayList<Task> combinedList = combineNormalAndEventsOrdered(normalTaskListThisDate, eventListThisDate);

            String dayOfWeekString = getDayString(date.getDayOfWeek());
            dayOfWeekString += "      " + date.format(DATE_FORMAT);

            _viewList.add(createTaskGroupDetailed(dayOfWeekString, combinedList, true));
            
        }
        while (!eventQueue.isEmpty()) {
            Task event = eventQueue.peek();
            LocalDate eventStartDate = event.getStartDate().toLocalDate();
            if (eventStartDate.isBefore(date) || eventStartDate.isEqual(date)) {
                eventQueue.poll();
                continue;
            } else {
                break;
            }
        }
        eventCopy = new ArrayList<Task>(eventQueue);
        if (eventCopy.isEmpty()) {
            return;
        }
        _viewList.add(createTaskGroupDetailed("Events", eventCopy, false));
    }

    private void processFloatingTask(ArrayList<Task> floatingTasks) {
        if (floatingTasks == null || floatingTasks.isEmpty()) {
            return;
        }
        _viewList.add(createFloatingTaskGroup(floatingTasks));
    }

    private void processNormalTasksAndEvents(ArrayList<Task> normalTasksList, ArrayList<Task> eventList) {
        if (normalTasksList.isEmpty() && eventList.isEmpty()) {
            return;
        }
        Queue<Task> normalTasksQueue = copyTasksIntoLinkedList(normalTasksList);
        ArrayList<Task> eventCopy = new ArrayList<Task>(eventList);
        processForOverdue(normalTasksQueue);
        processForTheWeek(normalTasksQueue, eventCopy);
        processRemainingTask(normalTasksQueue, eventCopy);
    }

    private ArrayList<Task> combineNormalAndEventsOrdered(ArrayList<Task> normalList, ArrayList<Task> eventList) {
        ArrayList<Task> combinedList = new ArrayList<Task>();

        while (!normalList.isEmpty() || !eventList.isEmpty()) {
            Task earlierToDo;
            if (normalList.isEmpty()) {
                earlierToDo = eventList.remove(FRONT_INDEX);
            } else if (eventList.isEmpty()) {
                earlierToDo = normalList.remove(FRONT_INDEX);
            } else {
                earlierToDo = extractTheEarlierTasks(normalList, eventList);
            }
            combinedList.add(earlierToDo);
        }
        return combinedList;
    }

    private Task extractTheEarlierTasks(ArrayList<Task> normalList, ArrayList<Task> eventList) {
        Task normalTask = normalList.get(0);
        Task event = eventList.get(0);
        LocalDate eventStartDate = event.getStartDate().toLocalDate();
        LocalTime eventStartTime = event.getStartDate().toLocalTime();
        LocalDate eventEndDate = event.getEndDate().toLocalDate();
        LocalTime eventEndTime = event.getEndDate().toLocalTime();
        LocalDate dueDate = normalTask.getEndDate().toLocalDate();
        LocalTime dueTime = normalTask.getEndDate().toLocalTime();

        if (eventStartDate.isBefore(dueDate)) {
            return eventList.remove(FRONT_INDEX);
        } else if (eventStartDate.isEqual(dueDate)) {
            if (eventStartTime.isBefore(dueTime)) {
                return eventList.remove(FRONT_INDEX);
            } else {
                return normalList.remove(FRONT_INDEX);
            }
        } else if (eventStartDate.isAfter(dueDate)) {
            return normalList.remove(FRONT_INDEX);
        } else if (dueDate.isBefore(eventEndDate)) {
            return normalList.remove(FRONT_INDEX);
        } else if (dueDate.isEqual(eventEndDate)) {
            if (dueTime.isBefore(eventEndTime)) {
                return normalList.remove(FRONT_INDEX);
            } else {
                return eventList.remove(FRONT_INDEX);
            }
        } else {
            return eventList.remove(FRONT_INDEX);
        }
    }

    private ArrayList<Task> extractEventsHappeningThisDate(ArrayList<Task> eventList, LocalDate eventDate, boolean isToRemoveStartDate) {
        ArrayList<Task> newEventList = new ArrayList<Task>();
        LocalDate startDate;
        LocalDate endDate;

        for (int i = 0; i < eventList.size(); i++) {
            Task task = eventList.get(i);
            startDate = task.getStartDate().toLocalDate();
            endDate = task.getEndDate().toLocalDate();
            if ((eventDate.isEqual(startDate) || eventDate.isAfter(startDate))
                    && (eventDate.isBefore(endDate) || eventDate.isEqual(endDate))) {
                newEventList.add(task);
                if (eventDate.isEqual(endDate)) {
                    eventList.remove(i);
                    i--;
                } else if(isToRemoveStartDate && eventDate.equals(startDate)){
                    eventList.remove(i);
                    i--;
                }
            }
        }

        return newEventList;
    }

    private String getDayString(DayOfWeek day) {
        return day.getDisplayName(TextStyle.FULL, Locale.US);
    }

    private ArrayList<Task> extractTaskDueBeforeThisDate(Queue<Task> taskQueue, LocalDate dueDate) {
        ArrayList<Task> dueList = new ArrayList<Task>();

        Task task = taskQueue.peek();
        LocalDate date;

        while (task != null) {
            date = task.getEndDate().toLocalDate();
            if (date.isBefore(dueDate)) {
                dueList.add(taskQueue.remove());
            } else {
                break;
            }
            task = taskQueue.peek();
        }
        return dueList;
    }

    private ArrayList<Task> extractTaskDueThisDate(Queue<Task> taskQueue, LocalDate dueDate) {
        ArrayList<Task> dueList = new ArrayList<Task>();

        Task task = taskQueue.peek();
        LocalDate date;

        while (task != null) {
            date = task.getEndDate().toLocalDate();
            if (date.isEqual(dueDate)) {
                dueList.add(taskQueue.remove());
            } else {
                break;
            }
            task = taskQueue.peek();
        }
        return dueList;
    }

    private TaskViewGroup createTaskOverdueGroup(ArrayList<Task> overdueList) {
        TaskViewGroup overdueGroup = createTaskGroupDetailed(GROUP_TITLE_OVERDUE, overdueList, false);
        return overdueGroup;
    }

    private TaskViewGroup createTaskTodayGroup(ArrayList<Task> todayList) {
        TaskViewGroup todayGroup = createTaskGroupDetailed(GROUP_TITLE_TODAY, todayList, true);
        return todayGroup;
    }

    private TaskViewGroup createTaskTomorrowGroup(ArrayList<Task> tomorrowList) {
        TaskViewGroup tomorrowGroup = createTaskGroupDetailed(GROUP_TITLE_TOMORROW, tomorrowList, true);
        return tomorrowGroup;
    }

    private TaskViewGroup createFloatingTaskGroup(ArrayList<Task> floatingTasks) {
        TaskViewGroup floatingGroup = createTaskGroup(GROUP_TITLE_FLOATING_TASKS, floatingTasks);
        return floatingGroup;
    }

    private LinkedList<Task> copyTasksIntoLinkedList(ArrayList<Task> list) {
        LinkedList<Task> linkedList = new LinkedList<Task>(list);
        return linkedList;
    }

    private TaskViewGroup createTaskGroupDetailed(String groupTitle, ArrayList<Task> list, boolean isDateHidden) {
        TaskViewGroup viewGroup = new TaskViewGroup(groupTitle);

        for (int i = 0; i < list.size(); i++) {
            Task t = list.get(i);
            TaskDetailedRow row = new TaskDetailedRow(t, index, isDateHidden);
            viewGroup.addDetialedTaskRow(row);
            _viewOrderedTaskList.add(t);
            index++;
        }
        return viewGroup;
    }

    private TaskViewGroup createTaskGroup(String groupTitle, ArrayList<Task> list) {
        TaskViewGroup viewGroup = new TaskViewGroup(groupTitle);

        for (int i = 0; i < list.size(); i++) {
            Task t = list.get(i);
            TaskRow row = new TaskRow(index, t.getTitle(), t.isCompleted());
            viewGroup.addTaskRow(row);
            _viewOrderedTaskList.add(t);
            index++;
        }
        return viewGroup;
    }
}
```
###### src\katnote\ui\TaskViewGroup.java
``` java
package katnote.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class TaskViewGroup extends AnchorPane {
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskViewGroup.fxml";

    @FXML
    private Label groupHeader;

    @FXML
    private VBox taskViewList;

    public TaskViewGroup(String header) {
        loadFXML();
        groupHeader.setText(header);
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void addTaskRow(TaskRow row) {
        taskViewList.getChildren().add(row);
    }

    public void addDetialedTaskRow(TaskDetailedRow row) {
        taskViewList.getChildren().add(row);
    }
    
    public VBox getListChildren(){
        return taskViewList;
    }
    
    public String getGroupHeaderText(){
        return groupHeader.getText();
    }

}
```
###### src\test\SystemTestDataParser.java
``` java
package test;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Locale;

import test.ViewDataPackage.TaskGroupPackage;

public class SystemTestDataParser {
    private static final String DATE_HEADER = "%1s      %2s";
    private static final String EVENT_ROW_KEYWORD = "EVENT";
    private static final String DATE_DIRECT_OUTPUT_KEYWORD = "DATE_DIRECT_OUTPUT";
    private static final String DATE_OUTPUT_KEYWORD = "DATE_OUTPUT";
    private static final String SPACE_STRING = " ";
    private static final String DATE_INPUT_WITH_TIME_KEYWORD = "DATE_INPUT_2";
    private static final String DATE_INPUT_KEYWORD = "DATE_INPUT";
    private static final String DATE_DIRECT_INPUT_KEYWORD = "DATE_DIRECT_INPUT";
    private static final String DIRECT_INPUT_KEYWORD = "DIRECT_INPUT";
    private static final String OUTPUT_KEYWORD = "OUTPUT";
    private static final String EVENT_INPUT_KEYWORD = "EVENT_INPUT";
    private static final String INPUT_KEYWORD = "INPUT";
    public static final String SYSTEM_TEST_FILE = "TestFiles/SystemTestFiles/systemTestInputOutput.txt";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final String EVENT_DATE_TIME_FORMAT = "Start: %1s %2s             End: %3s %4s";
    BufferedReader reader = null;
    ArrayList<String> inputs = new ArrayList<String>();
    ArrayList<ViewDataPackage> outputs = new ArrayList<ViewDataPackage>();

    public ArrayList<ViewDataPackage> getOutputs() {
        return outputs;
    }

    public ArrayList<String> getInputs() {
        return inputs;
    }

    public SystemTestDataParser() {
        try {
            reader = new BufferedReader(new FileReader(SYSTEM_TEST_FILE));
            String line = null;
            line = reader.readLine();
            while (line != null) {
                String input = null;
                if (line.equals(INPUT_KEYWORD)) {
                    input = processInput(reader);
                    inputs.add(input);
                    // System.out.println(input);
                } else if (line.equals(EVENT_INPUT_KEYWORD)) {
                    input = processEventInput(reader);
                    inputs.add(input);
                    // System.out.println(input);
                } else if (line.equals(OUTPUT_KEYWORD)) {
                    ViewDataPackage list = processOutput(reader);
                    outputs.add(list);
                    // System.out.println();
                } else if (line.equals(DIRECT_INPUT_KEYWORD)) {
                    input = reader.readLine();
                    inputs.add(input);
                    reader.readLine();
                }
                line = reader.readLine();
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public String processEventInput(BufferedReader reader) {
        String line = null;
        try {
            line = "";
            String input = "";
            for (int i = 0; i < 3; i++) {
                input += (reader.readLine() + SPACE_STRING);
            }
            line = reader.readLine();
            if (line.equals(DATE_DIRECT_INPUT_KEYWORD)) {
                input += reader.readLine();
            } else if (line.equals(DATE_INPUT_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
            } else if (line.equals(DATE_INPUT_WITH_TIME_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
                input += SPACE_STRING + reader.readLine();
            }
            input += SPACE_STRING + reader.readLine() + SPACE_STRING;
            line = reader.readLine();
            if (line.equals(DATE_DIRECT_INPUT_KEYWORD)) {
                input += reader.readLine();
            } else if (line.equals(DATE_INPUT_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
            } else if (line.equals(DATE_INPUT_WITH_TIME_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
                input += SPACE_STRING + reader.readLine();
            }
            reader.readLine();
            return input;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return line;
    }

    public String processInput(BufferedReader reader) {
        String line = null;
        try {
            line = "";
            String input = "";
            for (int i = 0; i < 3; i++) {
                input += (reader.readLine() + SPACE_STRING);
            }
            line = reader.readLine();
            if (line.equals(DATE_DIRECT_INPUT_KEYWORD)) {
                input += reader.readLine();
            } else if (line.equals(DATE_INPUT_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
            } else if (line.equals(DATE_INPUT_WITH_TIME_KEYWORD)) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(reader.readLine());
                int days = Integer.parseInt(reader.readLine());
                input += LocalDateTime.now().plusDays(days).format(formatter);
                input += SPACE_STRING + reader.readLine();
            }
            reader.readLine();
            return input;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return line;
    }

    public ViewDataPackage processOutput(BufferedReader reader) {
        String line = null;
        String response = null;
        TaskGroupPackage dataPack = null;
        ArrayList<TaskGroupPackage> array = new ArrayList<TaskGroupPackage>();
        try {
            // response is placed after output header
            line = reader.readLine();
            response = line;
            line = reader.readLine();
            while (line != null && !line.isEmpty()) {
                if (line.equals(DATE_OUTPUT_KEYWORD)) {
                    DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
                    int days = Integer.parseInt(reader.readLine());
                    LocalDateTime date = LocalDateTime.now().plusDays(days);
                    String day = date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
                    String dateString = date.format(dateFormat);
                    dateString = String.format(DATE_HEADER, day, dateString);
                    dataPack = processGroupPackage(reader, dateString);
                    array.add(dataPack);
                } else if (line.equals(DATE_DIRECT_OUTPUT_KEYWORD)) {
                    String header = reader.readLine();
                    dataPack = processGroupPackage(reader, header);
                    array.add(dataPack);
                }
                line = reader.readLine();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return new ViewDataPackage(array, response);
    }

    public TaskGroupPackage processGroupPackage(BufferedReader reader, String header) throws IOException {
        String line = reader.readLine();
        int count = Integer.parseInt(line);
        ArrayList<String> description = new ArrayList<String>();
        ArrayList<String> indexString = new ArrayList<String>();
        ArrayList<String> dateString = new ArrayList<String>();

        for (int i = 0; i < count; i++) {
            line = reader.readLine();
            if(line.equals(EVENT_ROW_KEYWORD)){
                indexString.add(reader.readLine());
                description.add(reader.readLine());
                DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
                int days = Integer.parseInt(reader.readLine());
                LocalDateTime dateStart = LocalDateTime.now().plusDays(days);
                String dateStartString = dateStart.format(dateFormat);
                String timeStartString = reader.readLine();
                days = Integer.parseInt(reader.readLine());
                LocalDateTime dateEnd = LocalDateTime.now().plusDays(days);
                String dateEndString = dateEnd.format(dateFormat);
                String timeEndString = reader.readLine();
                String eventDateString = String.format(EVENT_DATE_TIME_FORMAT, dateStartString, timeStartString,
                        dateEndString, timeEndString);
                dateString.add(eventDateString);   
                
            } else {
                indexString.add(line);
                description.add(reader.readLine());
                dateString.add(reader.readLine());                
            }
        }
        String[] desString = new String[description.size()];
        description.toArray(desString);
        String[] idString = new String[indexString.size()];
        indexString.toArray(idString);
        String[] dates = new String[dateString.size()];
        dateString.toArray(dates);

        return new TaskGroupPackage(header, desString, dates, idString);   
    }
}
```
###### src\test\TestGraphicalUserInterface.java
``` java
package test;

import static org.junit.Assert.*;

import java.io.File;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

import org.junit.Test;
import org.loadui.testfx.GuiTest;

import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.VBox;
import katnote.ui.CommandBarController;
import katnote.ui.GraphicalUserInterface;
import katnote.ui.TaskDetailedRow;
import katnote.ui.TaskRow;
import katnote.ui.TaskViewGroup;
import test.ViewDataPackage.TaskGroupPackage;

public class TestGraphicalUserInterface extends GuiTest {
    private static final String GROUP_TITLE_FLOATING_TASKS = "Task to do";
    TextField commandInput;
    GraphicalUserInterface app;     
    
    public void verifyTaskGroup(TaskGroupPackage expectedDataSet, TaskViewGroup taskGroup){
        String groupHeader = taskGroup.getGroupHeaderText();
        assertEquals(groupHeader, expectedDataSet.getGroupHeader());
        int noOfChildren = taskGroup.getListChildren().getChildren().size();
        
        String[] expectedTaskDescription = expectedDataSet.getTaskDesciptions();
        String[] expectedDateString = expectedDataSet.getDateString();
        String[] expectedIndexString = expectedDataSet.getIndexString();
        assertEquals(expectedTaskDescription.length, noOfChildren);
        ObservableList<Node> list = taskGroup.getListChildren().getChildren();
        
        if(groupHeader.equals(GROUP_TITLE_FLOATING_TASKS)){
            for(int i = 0; i < noOfChildren; i++){
                TaskRow row = (TaskRow)list.get(i);
                assertEquals(expectedTaskDescription[i], row.getDescription());
            }     
            
        } else {
            for(int i = 0; i < noOfChildren; i++){
                TaskDetailedRow row = (TaskDetailedRow)list.get(i);
                assertEquals(expectedTaskDescription[i], row.getDescription());
                assertEquals(expectedDateString[i], row.getDateString());
                assertEquals(expectedIndexString[i], row.getIndexString());
            }               
        }
             
    }

    public void verifyTaskGroupList(TaskGroupPackage[] testDataPackageArray, VBox taskGroupList){
        ObservableList<Node> nodes = taskGroupList.getChildren();
        assertEquals(testDataPackageArray.length, nodes.size());
        for(int i = 0; i < nodes.size(); i++){
            TaskViewGroup viewGroup = (TaskViewGroup) nodes.get(i);
            verifyTaskGroup(testDataPackageArray[i], viewGroup);
        }        
    }
    
    public void verifyView(ViewDataPackage data){
        Label responseLabel = (Label) find("#responseLabel");
        VBox taskGroupList = (VBox) find("#TaskList");
        assertEquals(data.getResponse(), responseLabel.getText());
        verifyTaskGroupList(data.getViewList(), taskGroupList);
    }

    @Test
    public void systemTest(){
        SystemTestDataParser testData = new SystemTestDataParser();
        ArrayList<String> inputs = testData.getInputs();
        ArrayList<ViewDataPackage> outputs = testData.getOutputs();
        
        assertEquals(inputs.size(), outputs.size());
        for(int i = 0; i < inputs.size(); i++){
            String input = inputs.get(i);
            ViewDataPackage data = outputs.get(i);
            //type(input).push(KeyCode.ENTER);
            commandInput.setText(input);
            System.out.println(String.format("Testing: \"%s\"", input));
            sleep(1, TimeUnit.SECONDS);
            push(KeyCode.ENTER);
            
            verifyView(data);            
        }
        
    }
    
    @Override
    protected Parent getRootNode() {
        return null;
    }

    @Override
    public void setupStage() throws Throwable {
        // reset data
        File f = new File("data.txt");
        f.delete();
        new Thread(() -> {
            GraphicalUserInterface.launch(GraphicalUserInterface.class);
        }).start();
        // let the application load
        sleep(2, TimeUnit.SECONDS);        
        click("#commandInputBox");
        commandInput = (TextField)find("#commandInputBox");
        
        app = GraphicalUserInterface.getInstance();
    }
}
```
###### src\test\ViewDataPackage.java
``` java
package test;

import java.util.ArrayList;

public class ViewDataPackage {

    public static class TaskGroupPackage {
        private String groupHeader;
        private String[] taskDescription;
        private String[] dateString;
        private String[] indexString;
        
        public TaskGroupPackage(String groupHeader, String[] taskDescription, String[] dateString, String[] indexString){
            this.groupHeader = groupHeader;
            this.taskDescription = taskDescription;
            this.dateString = dateString;
            this.indexString = indexString;
        }
        
        public String getGroupHeader(){
            return groupHeader;
        }
        public String[] getTaskDesciptions(){
            return taskDescription;
        }
        public String[] getDateString(){
            return dateString;
        }
        public String[] getIndexString(){
            return indexString;
        }        
    }   
    
    
    String response = null;
    TaskGroupPackage[] viewList = null;

    public ViewDataPackage(ArrayList<TaskGroupPackage> viewList, String response) {
        this.response = response;
        this.viewList = new TaskGroupPackage[viewList.size()];
        viewList.toArray(this.viewList);
    }

    public String getResponse() {
        return response;
    }

    public TaskGroupPackage[] getViewList() {
        return viewList;
    }
}
```
