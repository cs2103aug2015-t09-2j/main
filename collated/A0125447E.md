# A0125447E
###### bin\katnote\resources\ui\application.css
``` css
.TaskRowIcon {
	-fx-background-image: url('./catbulletblack.png');
	-fx-background-color: transparent; 
}
.TaskRowText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 16pt;	
	-fx-background-color: transparent; 
}
.catButton {
	-fx-background-image: url('./CLI_button.png');
	-fx-background-color: transparent; 
}
.catButton:hover {
	-fx-background-image: url('./CLI_button_hover.png');
	-fx-background-color: transparent; 
}
.catButton:pressed {
	-fx-background-image: url('./CLI_button_click.png');
	-fx-background-color: transparent; 
}
.check {
	-fx-background-image: url('./greentick.png');
	-fx-background-color: transparent; 
}
.katHeaderImage {
	-fx-background-image: url('./Kat.png');
	-fx-background-color: transparent; 
}
.katImage {
	-fx-background-image: url('./bigKat.png');
	-fx-background-color: transparent; 
	-fx-background-size: cover;
    -fx-background-repeat: stretch;   
}
.katBG {
	-fx-background-image: url('./KatNoteBG.png');
	-fx-background-color: transparent; 
    -fx-background-repeat: stretch;   
    -fx-background-size: 600 441;
}
.TaskRowDateText {
    -fx-font-family: "Sen Bold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 12pt;	
	-fx-background-color: transparent; 
}
.TaskGroupHeaderText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #EE7833;
    -fx-font-size: 18pt;	
	-fx-background-color: transparent; 
}
.title {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 24pt;
	-fx-background-color: transparent; 
}
.splashHeader {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 36pt;
	-fx-background-color: transparent; 
}
.splashText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 14pt;
	-fx-background-color: transparent; 
}
.scroll-pane > .viewport  {
    -fx-background-color:transparent;
}
```
###### src\katnote\resources\ui\application.css
``` css
.TaskRowIcon {
	-fx-background-image: url('./catbulletblack.png');
	-fx-background-color: transparent; 
}
.TaskRowText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 16pt;	
	-fx-background-color: transparent; 
}
.catButton {
	-fx-background-image: url('./CLI_button.png');
	-fx-background-color: transparent; 
}
.catButton:hover {
	-fx-background-image: url('./CLI_button_hover.png');
	-fx-background-color: transparent; 
}
.catButton:pressed {
	-fx-background-image: url('./CLI_button_click.png');
	-fx-background-color: transparent; 
}
.check {
	-fx-background-image: url('./greentick.png');
	-fx-background-color: transparent; 
}
.katHeaderImage {
	-fx-background-image: url('./Kat.png');
	-fx-background-color: transparent; 
}
.katImage {
	-fx-background-image: url('./bigKat.png');
	-fx-background-color: transparent; 
	-fx-background-size: cover;
    -fx-background-repeat: stretch;   
}
.katBG {
	-fx-background-image: url('./KatNoteBG.png');
	-fx-background-color: transparent; 
    -fx-background-repeat: stretch;   
    -fx-background-size: 600 441;
}
.TaskRowDateText {
    -fx-font-family: "Sen Bold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 12pt;	
	-fx-background-color: transparent; 
}
.TaskGroupHeaderText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #EE7833;
    -fx-font-size: 18pt;	
	-fx-background-color: transparent; 
}
.title {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 24pt;
	-fx-background-color: transparent; 
}
.splashHeader {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 36pt;
	-fx-background-color: transparent; 
}
.splashText {
    -fx-font-family: "Sen ExtraBold";
    -fx-text-fill: #FF9933;
    -fx-font-size: 14pt;
	-fx-background-color: transparent; 
}
.scroll-pane > .viewport  {
    -fx-background-color:transparent;
}
```
###### src\katnote\ui\CommandBarController.java
``` java
package katnote.ui;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

public class CommandBarController {
    private static final String NORMAL_STYLE = "-fx-text-fill: black;";
    private static final String ERROR_STYLE = "-fx-text-fill: red;";

    private GraphicalUserInterface mainUI;

    @FXML
    private TextField commandBar;
    @FXML
    private Label responseLabel;

    @FXML
    void onKeyPress(KeyEvent event) {
        if (event.getCode() == KeyCode.ENTER) {
            if (!commandBar.getText().isEmpty()) {
                mainUI.handleCommandInput(commandBar.getText());
                commandBar.clear();
            }
        }
    }

    @FXML
    void onInputClicked(MouseEvent event) {
        if (!commandBar.getText().isEmpty()) {
            mainUI.handleCommandInput(commandBar.getText());
            commandBar.clear();
        }
    }

    /**
     * Binds the main UI to the controller for forwarding controller events
     * 
     * @param mainUI
     */
    public void setMainUI(GraphicalUserInterface mainUI) {
        this.mainUI = mainUI;
    }

    /**
     * Display the error response and in red
     * 
     * @param response Error response message
     */
    public void setErrorText(String response) {
        setResponseText(response, true);
    }

    /**
     * Display response message and set its color.
     * 
     * @param response Response message to display
     * @param isError true for red and false for black
     */
    public void setResponseText(String response, boolean isError) {
        setResponseErrorState(isError);
        responseLabel.setText(response);
    }

    private void setResponseErrorState(boolean isError) {
        if (isError) {
            responseLabel.setStyle(ERROR_STYLE);
        } else {
            responseLabel.setStyle(NORMAL_STYLE);
        }
    }

}
```
###### src\katnote\ui\GraphicalUserInterface.java
``` java
package katnote.ui;

import katnote.KatNoteLogger;
import katnote.logic.Logic;
import katnote.logic.UIFeedback;
import katnote.logic.ViewState;

import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.scene.text.Font;

public class GraphicalUserInterface extends Application {
    private static final String MSG_LOG_INITILIZING_ROOT_LAYOUT = "initilizing rootLayout";
    private static final String APP_TITLE = "KatNote";
    private static final String RESOURCE_PATH_KAT_IMAGE = "/katnote/resources/ui/Kat.png";
    private static final String RESOURCE_PATH_SEN_BOLD = "/katnote/resources/ui/font/sen/sen-bold.otf";
    private static final String RESOURCE_PATH_SEN_EXTRABOLD = "/katnote/resources/ui/font/sen/sen-extrabold.otf";
    private static final String MSG_LOG_LOADING_RESOURCES = "loading resources";
    private static final Logger LOG = KatNoteLogger.getLogger(GraphicalUserInterface.class.getName());
    private static final String CORE_LAYOUT_FXML = "/katnote/resources/ui/CoreLayout.fxml";
    private static final String SPLASH_LAYOUT_FXML = "/katnote/resources/ui/SplashLayout.fxml";

    private static boolean _isTestMode = false;
    private static String _testFilePath = null;

    private StackPane rootLayout;
    private BorderPane coreLayout;
    private BorderPane splashLayout;
    private Stage primaryStage;
    private Logic logic;
    private TaskViewer taskViewer;
    private TaskViewFormatter displayedTaskFormat;
    private CommandBarController commandBarController;

    /**
     * Used to setup a custom file path for testing requirements.
     * 
     * @param isTestMode boolean to mark if the app will be starting up in test
     *            mode
     * @param testFilePath the test file path for the app to write data to
     */
    public static void configureTestMode(boolean isTestMode, String testFilePath) {
        _isTestMode = isTestMode;
        _testFilePath = testFilePath;
    }

    @Override
    public void start(Stage primaryStage) {
        loadResources();
        initialize(primaryStage);

        initRootLayout();
        setUpTaskViewer();
    }

    private void loadResources() {
        LOG.log(Level.INFO, MSG_LOG_LOADING_RESOURCES);
        Font.loadFont(getClass().getResource(RESOURCE_PATH_SEN_EXTRABOLD).toExternalForm(), 10);
        Font.loadFont(getClass().getResource(RESOURCE_PATH_SEN_BOLD).toExternalForm(), 10);
    }

    private void initialize(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle(APP_TITLE);
        this.primaryStage.getIcons().add(new Image(RESOURCE_PATH_KAT_IMAGE));
        try {
            if (_isTestMode) {
                logic = new Logic(_testFilePath);
            } else {
                logic = new Logic();
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    private void initRootLayout() {
        LOG.log(Level.FINE, MSG_LOG_INITILIZING_ROOT_LAYOUT);

        loadSplash();
        loadCoreLayout();
        Scene scene = setUpScene();
        setUpStage(scene);

        // to prevent focus on the commandBar
        splashLayout.requestFocus();
    }

    private void loadSplash() {
        try {
            // Load root layout from fxml file.
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource(SPLASH_LAYOUT_FXML));
            splashLayout = (BorderPane) loader.load();

            splashLayout.addEventFilter(KeyEvent.KEY_RELEASED, event -> hideSplash());
            splashLayout.addEventFilter(MouseEvent.MOUSE_CLICKED, event -> hideSplash());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void hideSplash() {
        rootLayout.getChildren().remove(splashLayout);
        splashLayout = null;
    }

    private void loadCoreLayout() {
        try {
            // Load root layout from fxml file.
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource(CORE_LAYOUT_FXML));
            coreLayout = (BorderPane) loader.load();
            commandBarController = loader.getController();
            commandBarController.setMainUI(this);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Scene setUpScene() {
        assert(coreLayout != null);
        assert(splashLayout != null);

        rootLayout = new StackPane();
        rootLayout.getChildren().add(coreLayout);
        rootLayout.getChildren().add(splashLayout);

        Scene scene = new Scene(rootLayout);
        return scene;
    }

    private void setUpStage(Scene scene) {
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();
    }

    private void setUpTaskViewer() {
        LOG.log(Level.INFO, "setUpTaskViewer");
        taskViewer = new TaskViewer();
        coreLayout.setCenter(taskViewer);
        displayedTaskFormat = updateTaskViewer(logic.getInitialViewState(), false);
        logic.setViewMapping(displayedTaskFormat.getOrderedTaskList());
    }

    private TaskViewFormatter updateTaskViewer(ViewState viewState, boolean isSearch) {
        LOG.log(Level.INFO, "updateTaskViewer");
        TaskViewFormatter viewFormat = new TaskViewFormatter(viewState, isSearch);
        taskViewer.loadTaskFormat(viewFormat);
        return viewFormat;
    }

    public void handleCommandInput(String inputText) {
        LOG.log(Level.FINE, "input recieved: " + inputText);
        try {
            UIFeedback feedback = logic.execute(inputText);
            boolean isErrorResponse = feedback.isAnError();
            commandBarController.setResponseText(feedback.getMessage(), isErrorResponse);
            if (feedback.isAnExit()) {
                primaryStage.close();
            } else if (!isErrorResponse) {
                processViewState(feedback);
            }
        } catch (Exception e) {
            LOG.log(Level.WARNING, "Exception: " + e.getMessage());
            commandBarController.setErrorText(e.getMessage());
            e.printStackTrace();
        }

    }

    private void processViewState(UIFeedback feedback) {
        ViewState viewState = feedback.getViewState();
        displayedTaskFormat = updateTaskViewer(viewState, feedback.isASearch());
        logic.setViewMapping(displayedTaskFormat.getOrderedTaskList());

    }

}
```
###### src\katnote\ui\TaskDetailedRow.java
``` java
package katnote.ui;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import katnote.task.Task;
import katnote.task.TaskType;

public class TaskDetailedRow extends AnchorPane {

    private static final String CHECKMARK_CLASS_NAME = "check";
    private static final String NORMAL_TASK_DATE_FORMAT = "Due: %1s %2s";
    private static final String NORMAL_TASK_TIME_FORMAT = "Due: %1s";
    private static final String EVENT_DATE_TIME_FORMAT = "Start: %1s           End: %2s";
    private static final String DATE_TIME_PATTERN = "dd MMM yy hh:mm a";
    private static final String TIME_PATTERN = "hh:mm a";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskDetailedRow.fxml";
    private static final String DISPLAY_INDEX_STRING = "%d.";

    @FXML
    private Label taskDescriptionLabel;
    @FXML
    private Label dateTimeLabel;
    @FXML
    private Pane checkmarkPane;
    @FXML
    private Label viewIndexLabel;
    private Task task;
    private int index;
    private boolean isDateHidden;

    public TaskDetailedRow(Task task, int viewIndex, boolean isDateHidden) {
        loadFXML();
        this.task = task;
        this.index = viewIndex;
        this.isDateHidden = isDateHidden;

        setIndexProperty(viewIndex);
        setDescriptionProperty();
        setDateTimeProperty();
        setCompletedProperty();
    }

    private void setIndexProperty(int viewIndex) {
        viewIndexLabel.setText(String.format(DISPLAY_INDEX_STRING, viewIndex));
    }

    private void setDescriptionProperty() {
        taskDescriptionLabel.setText(task.getTitle());
    }

    public String getDescription() {
        return taskDescriptionLabel.getText();
    }

    public String getDateString() {
        return dateTimeLabel.getText();
    }

    public String getIndexString() {
        return viewIndexLabel.getText();
    }

    private void setDateTimeProperty() {
        if (task.getTaskType() == TaskType.NORMAL) {
            LocalDateTime date = task.getEndDate();
            DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
            String dateString = date.format(dateFormat);
            DateTimeFormatter timeFormat = DateTimeFormatter.ofPattern(TIME_PATTERN);
            String timeString = date.format(timeFormat);
            String dateTime;
            if (isDateHidden) {
                dateTime = String.format(NORMAL_TASK_TIME_FORMAT, timeString);
            } else {
                dateTime = String.format(NORMAL_TASK_DATE_FORMAT, dateString, timeString);
            }
            dateTimeLabel.setText(dateTime);
        } else if (task.getTaskType() == TaskType.EVENT) {
            LocalDateTime startDate = task.getStartDate();
            LocalDateTime endDate = task.getEndDate();
            DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern(DATE_TIME_PATTERN);
            String startDateString = startDate.format(dateTimeFormat);
            String endDateString = endDate.format(dateTimeFormat);
            String dateTime = String.format(EVENT_DATE_TIME_FORMAT, startDateString, endDateString);
            dateTimeLabel.setText(dateTime);
        }
    }

    private void setCompletedProperty() {
        if (task.isCompleted()) {
            checkmarkPane.getStyleClass().add(CHECKMARK_CLASS_NAME);
        }
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
```
###### src\katnote\ui\TaskRow.java
``` java
package katnote.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;

public class TaskRow extends AnchorPane {
    private static final String CHECKMARK_CLASS_NAME = "check";
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskRow.fxml";
    private static final String DISPLAY_INDEX_STRING = "%d.";

    @FXML
    private Label taskDescriptionLabel;

    @FXML
    private Label timeLabel;

    @FXML
    private Label viewIndexLabel;

    @FXML
    private Pane checkmarkPane;

    public TaskRow(int viewIndex, String taskDescription, boolean isDone) {
        loadFXML();
        setIndexProperty(viewIndex);
        setTaskDescription(taskDescription);
        setCompletedProperty(isDone);
    }

    private void setIndexProperty(int viewIndex) {
        viewIndexLabel.setText(String.format(DISPLAY_INDEX_STRING, viewIndex));
    }

    public String getDescription() {
        return taskDescriptionLabel.getText();
    }

    private void setCompletedProperty(boolean isDone) {
        if (isDone) {
            checkmarkPane.getStyleClass().add(CHECKMARK_CLASS_NAME);
        }
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void setTaskDescription(String text) {
        taskDescriptionLabel.setText(text);
    }

}
```
###### src\katnote\ui\TaskViewer.java
``` java
package katnote.ui;

import java.io.IOException;
import java.util.ArrayList;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class TaskViewer extends AnchorPane {
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskViewer.fxml";

    @FXML
    private VBox taskViewGroupList;

    public TaskViewer() {
        loadFXML();
        taskViewGroupList.setFillWidth(true);
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void clearViewer() {
        taskViewGroupList.getChildren().clear();
    }

    public void loadTaskFormat(TaskViewFormatter listFormat) {
        clearViewer();
        updateTaskView(listFormat);
    }

    private void updateTaskView(TaskViewFormatter listFormat) {
        ArrayList<TaskViewGroup> viewList = listFormat.getFormattedViewGroupList();

        for (TaskViewGroup viewGroup : viewList) {
            taskViewGroupList.getChildren().add(viewGroup);
        }
    }

}
```
###### src\katnote\ui\TaskViewFormatter.java
``` java
package katnote.ui;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Locale;
import java.util.Queue;

import katnote.logic.ViewState;
import katnote.task.Task;

public class TaskViewFormatter {

    private static final String DAY_OF_WEEK_SPACING = "      ";
    private static final int FRONT_INDEX = 0;
    private static final int NUMBER_OF_DAYS_A_WEEK = 7;
    private static final String GROUP_TITLE_OVERDUE = "Overdue";
    private static final String GROUP_TITLE_FLOATING_TASKS = "Task to do";
    private static final String GROUP_TITLE_TODAY = "Today";
    private static final String GROUP_TITLE_TOMORROW = "Tomorrow";
    private static final String GROUP_HEADER_EVENTS = "Events";
    private static final String GROUP_TITLE_SEARCH_RESULT = "Search Result";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(DATE_PATTERN);

    private ArrayList<TaskViewGroup> _viewList = new ArrayList<TaskViewGroup>();
    private ArrayList<Task> _viewOrderedTaskList = new ArrayList<Task>();
    private int index = 1;

    /**
     * Creates a TaskViewFormatter object given a viewState and search state
     * 
     * @param viewState The viewState object which has the data to be displayed
     * @param isSearch boolean to indicate if it's a search state or not
     */
    public TaskViewFormatter(ViewState viewState, boolean isSearch) {
        ArrayList<Task> floatingTasks = viewState.getFloatingTasks();
        ArrayList<Task> normalTasks = viewState.getNormalTasks();
        ArrayList<Task> events = viewState.getEventTasks();
        if (isSearch) {
            processSearchListing(floatingTasks, normalTasks, events);
        } else {
            processFloatingTask(floatingTasks);
            processNormalTasksAndEvents(normalTasks, events);
        }
    }

    /**
     * Retrieves the ordered task list that is in the same order as the task
     * displayed
     * 
     * @return the list of task in a view-dependent order
     */
    public ArrayList<Task> getOrderedTaskList() {
        return _viewOrderedTaskList;
    }

    /**
     * Retrieves the formatted list for GUI
     * 
     * @return the list of formatted UI components
     */
    public ArrayList<TaskViewGroup> getFormattedViewGroupList() {
        return _viewList;
    }

    private void processSearchListing(ArrayList<Task> floatingTasks, ArrayList<Task> normalTasksList,
            ArrayList<Task> eventList) {
        processFloatingTask(floatingTasks);
        ArrayList<Task> combinedList = combineNormalAndEventsOrdered(normalTasksList, eventList);
        if (combinedList.isEmpty()) {
            return;
        }
        _viewList.add(createTaskGroupDetailed(GROUP_TITLE_SEARCH_RESULT, combinedList, false));
    }

    private void processForOverdue(Queue<Task> normalTasksQueue) {
        ArrayList<Task> overdueList = extractTaskDueBeforeThisDate(normalTasksQueue, LocalDate.now());
        if (overdueList.isEmpty()) {
            return;
        }
        TaskViewGroup taskGroupOverDue = createTaskOverdueGroup(overdueList);
        _viewList.add(taskGroupOverDue);

    }

    private void processForTheWeek(Queue<Task> normalTasksQueue, ArrayList<Task> eventList) {
        ArrayList<Task> remainingList;
        ArrayList<Task> eventRemainingWeekList;

        for (int i = 0; i <= NUMBER_OF_DAYS_A_WEEK; i++) {
            LocalDate dayDue = LocalDate.now().plusDays(i);
            remainingList = extractTaskDueThisDate(normalTasksQueue, dayDue);
            eventRemainingWeekList = extractEventsHappeningThisDate(eventList, dayDue, false);
            if (remainingList.isEmpty() && eventRemainingWeekList.isEmpty()) {
                continue;
            }

            ArrayList<Task> combinedList = combineNormalAndEventsOrdered(remainingList,
                    eventRemainingWeekList);

            if (i == 0) {
                TaskViewGroup taskGroupForToday = createTaskTodayGroup(combinedList);
                _viewList.add(taskGroupForToday);
            } else if (i == 1) {
                TaskViewGroup taskGroupForTomorrow = createTaskTomorrowGroup(combinedList);
                _viewList.add(taskGroupForTomorrow);
            } else {
                String dayOfWeekString = getDayString(dayDue.getDayOfWeek());
                dayOfWeekString += DAY_OF_WEEK_SPACING + dayDue.format(DATE_FORMAT);
                _viewList.add(createTaskGroupDetailed(dayOfWeekString, combinedList, true));
            }
        }
    }

    private void processForRemaining(Queue<Task> normalTasksQueue, ArrayList<Task> eventCopy) {
        LocalDate date = LocalDate.now();
        Queue<Task> eventQueue = copyTasksIntoLinkedList(eventCopy);
        date = processRemainingTaskAndEvents(normalTasksQueue, eventCopy, date);
        clearDisplayedEvents(date, eventQueue);
        processRemainingEvents(eventQueue);
    }

    private LocalDate processRemainingTaskAndEvents(Queue<Task> normalTasksQueue, ArrayList<Task> eventCopy,
            LocalDate date) {
        while (!normalTasksQueue.isEmpty()) {
            boolean isEventSelected = false;
            Task normalTask = normalTasksQueue.peek();
            Task event = (eventCopy.size() > 0) ? eventCopy.get(0) : null;
            LocalDate eventDateStart = (event != null) ? event.getStartDate().toLocalDate() : null;
            date = normalTask.getEndDate().toLocalDate();
            if (eventDateStart != null && date.isAfter(eventDateStart)) {
                date = eventDateStart;
                isEventSelected = true;
            }
            ArrayList<Task> normalTaskListThisDate = extractTaskDueThisDate(normalTasksQueue, date);
            ArrayList<Task> eventListThisDate = extractEventsHappeningThisDate(eventCopy, date,
                    isEventSelected);
            ArrayList<Task> combinedList = combineNormalAndEventsOrdered(normalTaskListThisDate,
                    eventListThisDate);

            String dayOfWeekString = getDayString(date.getDayOfWeek());
            dayOfWeekString += DAY_OF_WEEK_SPACING + date.format(DATE_FORMAT);

            _viewList.add(createTaskGroupDetailed(dayOfWeekString, combinedList, true));

        }
        return date;
    }

    private void processRemainingEvents(Queue<Task> eventQueue) {
        ArrayList<Task> eventCopy;
        eventCopy = new ArrayList<Task>(eventQueue);
        if (eventCopy.isEmpty()) {
            return;
        }
        _viewList.add(createTaskGroupDetailed(GROUP_HEADER_EVENTS, eventCopy, false));
    }

    private void clearDisplayedEvents(LocalDate date, Queue<Task> eventQueue) {
        while (!eventQueue.isEmpty()) {
            Task event = eventQueue.peek();
            LocalDate eventStartDate = event.getStartDate().toLocalDate();
            if (eventStartDate.isBefore(date) || eventStartDate.isEqual(date)) {
                eventQueue.poll();
                continue;
            } else {
                break;
            }
        }
    }

    private void processFloatingTask(ArrayList<Task> floatingTasks) {
        if (floatingTasks.isEmpty()) {
            return;
        }
        _viewList.add(createFloatingTaskGroup(floatingTasks));
    }

    private void processNormalTasksAndEvents(ArrayList<Task> normalTasksList, ArrayList<Task> eventList) {
        if (normalTasksList.isEmpty() && eventList.isEmpty()) {
            return;
        }
        Queue<Task> normalTasksQueue = copyTasksIntoLinkedList(normalTasksList);
        ArrayList<Task> eventCopy = new ArrayList<Task>(eventList);
        processForOverdue(normalTasksQueue);
        processForTheWeek(normalTasksQueue, eventCopy);
        processForRemaining(normalTasksQueue, eventCopy);
    }

    private ArrayList<Task> combineNormalAndEventsOrdered(ArrayList<Task> normalList,
            ArrayList<Task> eventList) {
        ArrayList<Task> combinedList = new ArrayList<Task>();

        while (!normalList.isEmpty() || !eventList.isEmpty()) {
            Task earlierToDo;
            if (normalList.isEmpty()) {
                earlierToDo = eventList.remove(FRONT_INDEX);
            } else if (eventList.isEmpty()) {
                earlierToDo = normalList.remove(FRONT_INDEX);
            } else {
                earlierToDo = extractTheEarlierTasks(normalList, eventList);
            }
            combinedList.add(earlierToDo);
        }
        return combinedList;
    }

    private Task extractTheEarlierTasks(ArrayList<Task> normalList, ArrayList<Task> eventList) {
        Task normalTask = normalList.get(FRONT_INDEX);
        Task event = eventList.get(FRONT_INDEX);
        LocalDate eventStartDate = event.getStartDate().toLocalDate();
        LocalTime eventStartTime = event.getStartDate().toLocalTime();
        LocalDate eventEndDate = event.getEndDate().toLocalDate();
        LocalTime eventEndTime = event.getEndDate().toLocalTime();
        LocalDate dueDate = normalTask.getEndDate().toLocalDate();
        LocalTime dueTime = normalTask.getEndDate().toLocalTime();

        if (eventStartDate.isBefore(dueDate)) {
            return eventList.remove(FRONT_INDEX);
        } else if (eventStartDate.isEqual(dueDate)) {
            if (eventStartTime.isBefore(dueTime)) {
                return eventList.remove(FRONT_INDEX);
            } else {
                return normalList.remove(FRONT_INDEX);
            }
        } else if (eventStartDate.isAfter(dueDate)) {
            return normalList.remove(FRONT_INDEX);
        } else if (dueDate.isBefore(eventEndDate)) {
            return normalList.remove(FRONT_INDEX);
        } else if (dueDate.isEqual(eventEndDate)) {
            if (dueTime.isBefore(eventEndTime)) {
                return normalList.remove(FRONT_INDEX);
            } else {
                return eventList.remove(FRONT_INDEX);
            }
        } else {
            return eventList.remove(FRONT_INDEX);
        }
    }

    private ArrayList<Task> extractEventsHappeningThisDate(ArrayList<Task> eventList, LocalDate eventDate,
            boolean isToRemoveStartDate) {
        ArrayList<Task> newEventList = new ArrayList<Task>();

        for (int i = 0; i < eventList.size(); i++) {
            Task task = eventList.get(i);
            boolean isSuccess = transferTaskToNewList(eventDate, isToRemoveStartDate, newEventList, task);
            if (isSuccess) {
                eventList.remove(i);
                i--;
            }
        }

        return newEventList;
    }

    private boolean transferTaskToNewList(LocalDate eventDate, boolean isToRemoveStartDate,
            ArrayList<Task> newEventList, Task task) {
        LocalDate startDate;
        LocalDate endDate;
        startDate = task.getStartDate().toLocalDate();
        endDate = task.getEndDate().toLocalDate();
        if ((eventDate.isEqual(startDate) || eventDate.isAfter(startDate))
                && (eventDate.isBefore(endDate) || eventDate.isEqual(endDate))) {
            newEventList.add(task);

            if (eventDate.isEqual(endDate)) {
                return true;
            } else if (isToRemoveStartDate && eventDate.equals(startDate)) {
                return true;
            }
        }
        return false;
    }

    private String getDayString(DayOfWeek day) {
        return day.getDisplayName(TextStyle.FULL, Locale.US);
    }

    private ArrayList<Task> extractTaskDueBeforeThisDate(Queue<Task> taskQueue, LocalDate dueDate) {
        ArrayList<Task> dueList = new ArrayList<Task>();

        Task task = taskQueue.peek();
        LocalDate date;

        while (task != null) {
            date = task.getEndDate().toLocalDate();
            if (date.isBefore(dueDate)) {
                dueList.add(taskQueue.remove());
            } else {
                break;
            }
            task = taskQueue.peek();
        }
        return dueList;
    }

    private ArrayList<Task> extractTaskDueThisDate(Queue<Task> taskQueue, LocalDate dueDate) {
        ArrayList<Task> dueList = new ArrayList<Task>();

        Task task = taskQueue.peek();
        LocalDate date;

        while (task != null) {
            date = task.getEndDate().toLocalDate();
            if (date.isEqual(dueDate)) {
                dueList.add(taskQueue.remove());
            } else {
                break;
            }
            task = taskQueue.peek();
        }
        return dueList;
    }

    private TaskViewGroup createTaskOverdueGroup(ArrayList<Task> overdueList) {
        TaskViewGroup overdueGroup = createTaskGroupDetailed(GROUP_TITLE_OVERDUE, overdueList, false);
        return overdueGroup;
    }

    private TaskViewGroup createTaskTodayGroup(ArrayList<Task> todayList) {
        TaskViewGroup todayGroup = createTaskGroupDetailed(GROUP_TITLE_TODAY, todayList, true);
        return todayGroup;
    }

    private TaskViewGroup createTaskTomorrowGroup(ArrayList<Task> tomorrowList) {
        TaskViewGroup tomorrowGroup = createTaskGroupDetailed(GROUP_TITLE_TOMORROW, tomorrowList, true);
        return tomorrowGroup;
    }

    private TaskViewGroup createFloatingTaskGroup(ArrayList<Task> floatingTasks) {
        TaskViewGroup floatingGroup = createTaskGroup(GROUP_TITLE_FLOATING_TASKS, floatingTasks);
        return floatingGroup;
    }

    private LinkedList<Task> copyTasksIntoLinkedList(ArrayList<Task> list) {
        LinkedList<Task> linkedList = new LinkedList<Task>(list);
        return linkedList;
    }

    private TaskViewGroup createTaskGroupDetailed(String groupTitle, ArrayList<Task> list,
            boolean isDateHidden) {
        TaskViewGroup viewGroup = new TaskViewGroup(groupTitle);

        for (int i = 0; i < list.size(); i++) {
            Task t = list.get(i);
            TaskDetailedRow row = new TaskDetailedRow(t, index, isDateHidden);
            viewGroup.addDetialedTaskRow(row);
            _viewOrderedTaskList.add(t);
            index++;
        }
        return viewGroup;
    }

    private TaskViewGroup createTaskGroup(String groupTitle, ArrayList<Task> list) {
        TaskViewGroup viewGroup = new TaskViewGroup(groupTitle);

        for (int i = 0; i < list.size(); i++) {
            Task t = list.get(i);
            TaskRow row = new TaskRow(index, t.getTitle(), t.isCompleted());
            viewGroup.addTaskRow(row);
            _viewOrderedTaskList.add(t);
            index++;
        }
        return viewGroup;
    }
}
```
###### src\katnote\ui\TaskViewGroup.java
``` java
package katnote.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

public class TaskViewGroup extends AnchorPane {
    private static final String LAYOUT_FXML = "/katnote/resources/ui/TaskViewGroup.fxml";

    @FXML
    private Label groupHeader;

    @FXML
    private VBox taskViewList;

    public TaskViewGroup(String header) {
        loadFXML();
        groupHeader.setText(header);
    }

    private void loadFXML() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LAYOUT_FXML));
        loader.setController(this);
        loader.setRoot(this);

        try {
            loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void addTaskRow(TaskRow row) {
        taskViewList.getChildren().add(row);
    }

    public void addDetialedTaskRow(TaskDetailedRow row) {
        taskViewList.getChildren().add(row);
    }

    public VBox getListChildren() {
        return taskViewList;
    }

    public String getGroupHeaderText() {
        return groupHeader.getText();
    }

}
```
###### src\test\SystemTestDataParser.java
``` java
package test;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Locale;

import test.ViewDataPackage.TaskGroupPackage;

public class SystemTestDataParser {
    private static final String DATE_OUTPUT = "DATE_OUTPUT";
    private static final String DATE_HEADER = "%1s      %2s";
    private static final String EVENT_ROW_KEYWORD = "EVENT";
    private static final String DIRECT_OUTPUT_KEYWORD = "DIRECT_OUTPUT_HEADER";
    private static final String DATE_OUTPUT_KEYWORD = "DATE_OUTPUT_HEADER";
    private static final String SPACE_STRING = " ";
    private static final String DATE_INPUT_WITH_TIME_KEYWORD = "DATE_INPUT_2";
    private static final String DATE_INPUT_KEYWORD = "DATE_INPUT";
    private static final String DATE_DIRECT_INPUT_KEYWORD = "DATE_DIRECT_INPUT";
    private static final String DIRECT_INPUT_KEYWORD = "DIRECT_INPUT";
    private static final String OUTPUT_KEYWORD = "OUTPUT";
    private static final String EVENT_INPUT_KEYWORD = "EVENT_INPUT";
    private static final String INPUT_KEYWORD = "INPUT";
    public static final String SYSTEM_TEST_FILE = "TestFiles/SystemTestFiles/systemTestInputOutput.txt";
    private static final String DATE_PATTERN = "dd MMM yy";
    private static final String EVENT_DATE_TIME_FORMAT = "Start: %1s %2s           End: %3s %4s";
    private BufferedReader reader = null;
    private ArrayList<String> inputs = new ArrayList<String>();
    private ArrayList<ViewDataPackage> outputs = new ArrayList<ViewDataPackage>();

    public ArrayList<ViewDataPackage> getOutputs() {
        return outputs;
    }

    public ArrayList<String> getInputs() {
        return inputs;
    }

    public SystemTestDataParser() {
        try {
            reader = new BufferedReader(new FileReader(SYSTEM_TEST_FILE));
            String line = null;
            line = readLine();
            while (line != null) {
                String input = null;
                if (line.equals(INPUT_KEYWORD)) {
                    input = processInput();
                    inputs.add(input);
                    // System.out.println(input);
                } else if (line.equals(EVENT_INPUT_KEYWORD)) {
                    input = processEventInput();
                    inputs.add(input);
                    // System.out.println(input);
                } else if (line.equals(OUTPUT_KEYWORD)) {
                    ViewDataPackage list = processOutput(reader);
                    outputs.add(list);
                    // System.out.println();
                } else if (line.equals(DIRECT_INPUT_KEYWORD)) {
                    input = readLine();
                    inputs.add(input);
                    readLine();
                }
                line = readLine();
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private String readLine() throws IOException {
        String line = null;
        line = reader.readLine();
        if (line == null) {
            return line;
        }
        // filter comment lines
        while (!line.isEmpty() && line.charAt(0) == '#') {
            line = reader.readLine();
        }
        return line;
    }

    public String processEventInput() {
        String line = null;
        try {
            line = "";
            String input = "";
            input += readLine() + SPACE_STRING; // first part of input
            line = readLine(); // date header
            input += processDateInput(line);
            input += SPACE_STRING + readLine() + SPACE_STRING; // event
                                                               // conntector
                                                               // string
            line = readLine(); // date header
            input += processDateInput(line);
            readLine(); // newline
            return input;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return line;
    }

    private String processDateInput(String line) throws IOException {
        String input = "";
        if (line.equals(DATE_DIRECT_INPUT_KEYWORD)) {
            input += readLine();
        } else if (line.equals(DATE_INPUT_KEYWORD)) {
            input += prcoessSingleDate();
        } else if (line.equals(DATE_INPUT_WITH_TIME_KEYWORD)) {
            input += prcoessSingleDate();
            input += SPACE_STRING + readLine();
        }
        return input;
    }

    public String processInput() {
        String line = null;
        try {
            line = "";
            String input = "";
            input += readLine() + SPACE_STRING; // first part of input
            line = readLine(); // date header
            input += processDateInput(line);
            readLine(); // newline
            return input;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return line;
    }

    private String prcoessSingleDate() throws IOException {
        String dateFormat = readLine();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(dateFormat);
        int days = Integer.parseInt(readLine());
        String date = LocalDateTime.now().plusDays(days).format(formatter);
        return date;
    }

    public ViewDataPackage processOutput(BufferedReader reader) {
        String line = null;
        String response = null;
        TaskGroupPackage dataPack = null;
        ArrayList<TaskGroupPackage> array = new ArrayList<TaskGroupPackage>();
        try {
            // response is placed after output header
            line = readLine();
            response = line;
            line = readLine();
            while (line != null && !line.isEmpty()) {
                if (line.equals(DATE_OUTPUT_KEYWORD)) {
                    DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
                    int days = Integer.parseInt(readLine());
                    LocalDateTime date = LocalDateTime.now().plusDays(days);
                    String day = date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
                    String dateString = date.format(dateFormat);
                    dateString = String.format(DATE_HEADER, day, dateString);
                    dataPack = processGroupPackage(reader, dateString);
                    array.add(dataPack);
                } else if (line.equals(DIRECT_OUTPUT_KEYWORD)) {
                    String header = readLine();
                    dataPack = processGroupPackage(reader, header);
                    array.add(dataPack);
                }
                line = readLine();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return new ViewDataPackage(array, response);
    }

    public TaskGroupPackage processGroupPackage(BufferedReader reader, String header) throws IOException {
        String line = readLine();
        int count = Integer.parseInt(line);
        ArrayList<String> description = new ArrayList<String>();
        ArrayList<String> indexString = new ArrayList<String>();
        ArrayList<String> dateStrings = new ArrayList<String>();

        for (int i = 0; i < count; i++) {
            line = readLine();
            if (line.equals(EVENT_ROW_KEYWORD)) {
                indexString.add(readLine());
                description.add(readLine());
                DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
                int days = Integer.parseInt(readLine());
                LocalDateTime dateStart = LocalDateTime.now().plusDays(days);
                String dateStartString = dateStart.format(dateFormat);
                String timeStartString = readLine();
                days = Integer.parseInt(readLine());
                LocalDateTime dateEnd = LocalDateTime.now().plusDays(days);
                String dateEndString = dateEnd.format(dateFormat);
                String timeEndString = readLine();
                String eventDateString = String.format(EVENT_DATE_TIME_FORMAT, dateStartString,
                        timeStartString, dateEndString, timeEndString);
                dateStrings.add(eventDateString);

            } else if (line.equals(DATE_OUTPUT)) {
                indexString.add(readLine());
                description.add(readLine());

                DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_PATTERN);
                String dueDateString = readLine() + SPACE_STRING; // "Due:"
                int days = Integer.parseInt(readLine());
                LocalDateTime date = LocalDateTime.now().plusDays(days);
                dueDateString += date.format(dateFormat) + SPACE_STRING;
                dueDateString += readLine();
                dateStrings.add(dueDateString);

            } else {
                indexString.add(line);
                description.add(readLine());
                dateStrings.add(readLine());
            }
        }
        String[] desString = new String[description.size()];
        description.toArray(desString);
        String[] idString = new String[indexString.size()];
        indexString.toArray(idString);
        String[] dates = new String[dateStrings.size()];
        dateStrings.toArray(dates);

        return new TaskGroupPackage(header, desString, dates, idString);
    }
}
```
###### src\test\TestGraphicalUserInterface.java
``` java
package test;

import static org.junit.Assert.*;

import java.io.File;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

import org.junit.After;
import org.junit.Test;
import org.loadui.testfx.GuiTest;

import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.VBox;
import katnote.ui.GraphicalUserInterface;
import katnote.ui.TaskDetailedRow;
import katnote.ui.TaskRow;
import katnote.ui.TaskViewGroup;
import test.ViewDataPackage.TaskGroupPackage;

public class TestGraphicalUserInterface extends GuiTest {
    private static final String GROUP_TITLE_FLOATING_TASKS = "Task to do";
    private static final String TEST_FILE_PATH = "TestFiles/SystemTestFiles/";
    private TextField commandInput;

    public void verifyTaskGroup(TaskGroupPackage expectedDataSet, TaskViewGroup taskGroup) {
        String groupHeader = taskGroup.getGroupHeaderText();
        assertEquals(groupHeader, expectedDataSet.getGroupHeader());
        int noOfChildren = taskGroup.getListChildren().getChildren().size();

        String[] expectedTaskDescription = expectedDataSet.getTaskDesciptions();
        String[] expectedDateString = expectedDataSet.getDateString();
        String[] expectedIndexString = expectedDataSet.getIndexString();
        assertEquals(expectedTaskDescription.length, noOfChildren);
        ObservableList<Node> list = taskGroup.getListChildren().getChildren();

        if (groupHeader.equals(GROUP_TITLE_FLOATING_TASKS)) {
            for (int i = 0; i < noOfChildren; i++) {
                TaskRow row = (TaskRow) list.get(i);
                assertEquals(expectedTaskDescription[i], row.getDescription());
            }

        } else {
            for (int i = 0; i < noOfChildren; i++) {
                TaskDetailedRow row = (TaskDetailedRow) list.get(i);
                assertEquals(expectedTaskDescription[i], row.getDescription());
                assertEquals(expectedDateString[i], row.getDateString());
                assertEquals(expectedIndexString[i], row.getIndexString());
            }
        }

    }

    public void verifyTaskGroupList(TaskGroupPackage[] testDataPackageArray, VBox taskGroupList) {
        ObservableList<Node> nodes = taskGroupList.getChildren();
        assertEquals(testDataPackageArray.length, nodes.size());
        for (int i = 0; i < nodes.size(); i++) {
            TaskViewGroup viewGroup = (TaskViewGroup) nodes.get(i);
            verifyTaskGroup(testDataPackageArray[i], viewGroup);
        }
    }

    public void verifyView(ViewDataPackage data) {
        Label responseLabel = (Label) find("#responseLabel");
        VBox taskGroupList = (VBox) find("#TaskList");
        assertEquals(data.getResponse(), responseLabel.getText());
        verifyTaskGroupList(data.getViewList(), taskGroupList);
    }

    @Test
    public void systemTest() {
        SystemTestDataParser testData = new SystemTestDataParser();
        ArrayList<String> inputs = testData.getInputs();
        ArrayList<ViewDataPackage> outputs = testData.getOutputs();

        assertEquals(inputs.size(), outputs.size());

        // mouse test
        String input = inputs.get(0);
        ViewDataPackage data = outputs.get(0);
        commandInput.setText(input);
        System.out.println(String.format("Testing: \"%s\"", input));
        click("#inputButton");
        click("#commandInputBox");

        for (int i = 1; i < inputs.size(); i++) {
            input = inputs.get(i);
            data = outputs.get(i);
            // type(input).push(KeyCode.ENTER);
            commandInput.setText(input);
            System.out.println(String.format("Testing: \"%s\"", input));
            sleep(250, TimeUnit.MILLISECONDS);
            push(KeyCode.ENTER);
            sleep(250, TimeUnit.MILLISECONDS);

            verifyView(data);
        }

    }

    @Override
    protected Parent getRootNode() {
        return null;
    }

    @After
    public void cleanUp() {
        File f = new File(TEST_FILE_PATH + "data.txt");
        if (f.exists()) {
            f.delete();
        }
    }

    @Override
    public void setupStage() throws Throwable {
        GraphicalUserInterface.configureTestMode(true, TEST_FILE_PATH);

        new Thread(() -> {
            GraphicalUserInterface.launch(GraphicalUserInterface.class);
        }).start();
        // let the application load
        sleep(2, TimeUnit.SECONDS);
        click("#commandInputBox");
        commandInput = (TextField) find("#commandInputBox");

    }
}
```
###### src\test\ViewDataPackage.java
``` java
package test;

import java.util.ArrayList;

public class ViewDataPackage {

    public static class TaskGroupPackage {
        private String groupHeader;
        private String[] taskDescription;
        private String[] dateString;
        private String[] indexString;

        public TaskGroupPackage(String groupHeader, String[] taskDescription, String[] dateString,
                String[] indexString) {
            this.groupHeader = groupHeader;
            this.taskDescription = taskDescription;
            this.dateString = dateString;
            this.indexString = indexString;
        }

        public String getGroupHeader() {
            return groupHeader;
        }

        public String[] getTaskDesciptions() {
            return taskDescription;
        }

        public String[] getDateString() {
            return dateString;
        }

        public String[] getIndexString() {
            return indexString;
        }
    }

    private String response = null;
    private TaskGroupPackage[] viewList = null;

    public ViewDataPackage(ArrayList<TaskGroupPackage> viewList, String response) {
        this.response = response;
        this.viewList = new TaskGroupPackage[viewList.size()];
        viewList.toArray(this.viewList);
    }

    public String getResponse() {
        return response;
    }

    public TaskGroupPackage[] getViewList() {
        return viewList;
    }
}
```
