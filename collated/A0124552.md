# A0124552
###### src\katnote\Model.java
``` java
package katnote;

import java.io.*;
import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.json.simple.JSONArray;
import org.json.simple.JSONValue;
import org.json.simple.parser.ContainerFactory;
import org.json.simple.parser.JSONParser;

import katnote.command.CommandDetail;
import katnote.command.CommandProperties;
import katnote.parser.EditTaskOption;
import katnote.task.Task;
import katnote.task.TaskType;
import katnote.utils.DateTimeUtils;
import katnote.utils.KatDateTime;

/**
 * The main class in the Storage component. Creates 3 other sub classes:
 * StorageEncoder, StorageDecoder and StorageData. The main class has a native
 * parser for the commands sent from the Logic component.
 * 
 * @author sk
 *
 */
public class Model {

    // Private Variables
    private StorageDecoder _decoder;
    private StorageEncoder _encoder;
    private StorageData _data;

    private Hashtable<String, String> _definitions;

    private ArrayList<Task> _dataLog;
    private ArrayList<Task> _dataNormalTasks;
    private ArrayList<Task> _dataFloatingTasks;
    private ArrayList<Task> _dataEventTasks;

    private Stack<String> _undoLog;
    private Stack<String> _redoLog;
    private Stack<Task> _undoTaskObjLog;
    private Stack<Task> _redoTaskObjLog;
    private String _response;

    // Constants
    private static final String DATA_FILENAME = "data.txt";
    private static final String DATA_BACKUP_FILENAME = "oldData.txt";
    private static final int MAX_BUFFER_SIZE = 1024;
    private static final int TASK_ARG_SIZE = 10;

    private static final String NULL_DATE = "null";
    private static final String STR_TRUE = "true";
    private static final String STR_FALSE = "false";

    private static final int INDEX_ID = 0;
    private static final int INDEX_TITLE = 1;
    private static final int INDEX_TASK_TYPE = 2;
    private static final int INDEX_START_DATE = 3;
    private static final int INDEX_END_DATE = 4;
    private static final int INDEX_REPEAT_OPTION = 5;
    private static final int INDEX_TERMINATE_DATE = 6;
    private static final int INDEX_DESCRIPTION = 7;
    private static final int INDEX_CATEGORY = 8;
    private static final int INDEX_COMPLETED = 9;

    // Messages
    private static final String MSG_MIGRATE_CONFIRM = "Save location has successfully moved from %s to %s.";
    private static final String MSG_DATA_FILE_READY = "data.txt is ready for use in %s";
    private static final String MSG_TASK_ADDED = "Task: %s added.";
    private static final String MSG_EDIT_TASK_COMPLETED = "Task: %s is marked completed.";
    private static final String MSG_EDIT_TASK_INCOMPLETE = "Task: %s is marked incomplete.";
    private static final String MSG_EDIT_TASK_MODIFIED = "Task: %s is successfully modified.";
    private static final String MSG_EDIT_TASK_DELETED = "Task: %s is successfully deleted.";
    private static final String MSG_EDIT_TASK_REPLACED = "Task: %s is successfully replaced with %s";
    private static final String MSG_EDIT_TASK_CLEAR_ALL = "All tasks cleared.";
    private static final String MSG_EDIT_TASK_CLEAR_COMPLETED = "All completed tasks cleared.";
    private static final String MSG_EDIT_TASK_CLEAR_INCOMPLETE = "All incomplete tasks cleared.";
    private static final String MSG_EDIT_TASK_POSTPONE = "Task: %s is postponed to %s";
    private static final String MSG_UNDO_CONFIRM = "%s %s undone.";
    private static final String MSG_REDO_CONFIRM = "%s %s redone.";
    private static final String MSG_IMPORT_CONFIRM = "Successfully imported %s to %s";
    private static final String MSG_DEFINITION_REPLACED = "Definition for %s set to %s";
    private static final String MSG_DEFINITION_ADDED = "New definition for %s set to %s";

    private static final String MSG_ERR_IO = "Invalid input, input is either corrupted, missing or inaccessible.";
    private static final String MSG_ERR_MISSING_DATA = "Cannot locate data.txt in source.";
    private static final String MSG_ERR_INVALID_ARGUMENTS = "Error. Invalid arguments.";
    private static final String MSG_ERR_INVALID_MODIFICATION = "Unable to execute this modification.";
    private static final String MSG_ERR_JSON_PARSE_ERROR = "Unabled to parse String to JSONObject.";
    private static final String MSG_ERR_TASK_NOT_MODIFIED = "Unable to process modify parameters.";
    private static final String MSG_ERR_IMPORT_LOCATION_MISSING = "Unable to find data.txt in specified import location.";
    private static final String MSG_ERR_ALREADY_COMPLETE = "Task: %s is already completed.";
    private static final String MSG_ERR_ALREADY_INCOMPLETE = "Task: %s is already incomplete.";
    private static final String MSG_ERR_UNDO = "No actions left to undo.";
    private static final String MSG_ERR_REDO = "No actions left to redo.";
    private static final String MSG_ERR_REVERSE_EXCEPTION = "Unable to perform a reverse for action : ";
    private static final String MSG_ERR_REVERSE_ADD = "Unable to perform reverse for adding of task : ";
    private static final String MSG_ERR_REVERSE_MODIFY = "Unable to perform reverse for modifying of task : ";
    private static final String MSG_ERR_REVERSE_DELETE = "Unable to perform reverse for deleting of task : ";
    private static final String MSG_ERR_REVERSE_COMPLETE = "Unable to perform reverse for completion of task : ";
    private static final String MSG_ERR_REVERSE_REPLACE = "Unable to perform reverse for replacing of task : ";
    private static final String MSG_ERR_REVERSE_POSTPONE = "Unable to perform reverse for postponed task.";
    private static final String MSG_ERR_START_AFTER_END = "Invalid start date. Start date is after end date.";
    private static final String MSG_ERR_INVALID_TASK_TYPE = "Invalid Task Type. Expecting Event task type.";
    private static final String MSG_ERR_PARSE_EXCEPTION = "Error: Unable to parse inputs to Task object. ";

    private static final String MSG_LOG_START = "<start>";

    // Task Property Keys
    private static final String KEY_ID = "id";
    private static final String KEY_TITLE = "title";
    private static final String KEY_TASK_TYPE = "task_type";
    private static final String KEY_START_DATE = "start_date";
    private static final String KEY_END_DATE = "end_date";
    private static final String KEY_REPEAT_OPTION = "repeat_option";
    private static final String KEY_TERMINATE_DATE = "terminate_date";
    private static final String KEY_DESCRIPTION = "description";
    private static final String KEY_CATEGORY = "category";
    private static final String KEY_COMPLETED = "completed";

    private static final String TYPE_NORMAL = "NORMAL";
    private static final String TYPE_FLOATING = "FLOATING";
    private static final String TYPE_EVENT = "EVENT";

    private static final String CLEAR_ALL = "clear all";
    private static final String CLEAR_COMPLETED = "clear completed";
    private static final String CLEAR_INCOMPLETE = "clear incomplete";

    // Undo and Redo
    private static final Exception REVERSE_EXCEPTION = new Exception("Reverse Exception");

    private static final String ADD_TASK = "Add Task:";
    private static final String EDIT_MODIFY = "Modify Task:";
    private static final String EDIT_DELETE = "Delete Task:";
    private static final String EDIT_COMPLETE = "Mark Task:";
    private static final String EDIT_REPLACE = "Replaced Task:";
    private static final String EDIT_POSTPONE = "Postponed Task:";

    // Standard Default Definitions
    private static final String MORNING = "9.00am";
    private static final String AFTERNOON = "12.00pm";
    private static final String NIGHT = "9.00pm";
    private static final String EVENING = "7.00pm";

    // Format
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ISO_DATE_TIME;

    // Constructor
    public Model(String path) throws Exception {

        _data = new StorageData(path);
        _decoder = new StorageDecoder();
        _encoder = new StorageEncoder();
        _undoLog = new Stack<String>();
        _undoTaskObjLog = new Stack<Task>();
        _redoLog = new Stack<String>();
        _redoTaskObjLog = new Stack<Task>();
        _dataNormalTasks = new ArrayList<Task>();
        _dataFloatingTasks = new ArrayList<Task>();
        _dataEventTasks = new ArrayList<Task>();
        initDefinitions();
        _dataLog = _decoder.decode();
        splitTaskType(_dataLog);
    }

    /**
     * Add a task and encode it into the data file with its ID.
     * 
     * @param task
     *            with all the required data.
     * @return the response message of a successful addition of a task.
     * @throws Exception
     */
    public String addTask(Task task) throws Exception {

        task.setID(getNextID());
        _dataLog.add(task);

        splitTaskType(task);

        _encoder.encode();

        updateUndoLog(ADD_TASK, task);

        _response = String.format(MSG_TASK_ADDED, task.getTitle());
        return _response;
    }

    /**
     * Edit a task and marks it as completed.
     * 
     * @param taskID
     *            which will correspond to the index of the task in the dataLog.
     * @return the response message of a successful change in the completed
     *         flag.
     * @throws Exception
     */
    public String editComplete(int taskID) throws Exception {

        Task editedTask = _dataLog.get(taskID);
        if (editedTask.isCompleted()) {
            _response = handleException(null, String.format(MSG_ERR_ALREADY_COMPLETE, editedTask.getTitle()));
            return _response;
        }

        editedTask.setCompleted(true);

        _encoder.encode();

        updateUndoLog(EDIT_COMPLETE, editedTask);

        _response = String.format(MSG_EDIT_TASK_COMPLETED, editedTask.getTitle());
        return _response;
    }

    public String editIncomplete(int taskID) throws Exception {

        Task editedTask = _dataLog.get(taskID);
        if (!editedTask.isCompleted()) {
            _response = handleException(null,
                    String.format(MSG_ERR_ALREADY_INCOMPLETE, editedTask.getTitle()));
            return _response;
        }

        editedTask.setCompleted(false);

        _encoder.encode();

        updateUndoLog(EDIT_COMPLETE, editedTask);

        _response = String.format(MSG_EDIT_TASK_INCOMPLETE, editedTask.getTitle());
        return _response;
    }

    /**
     * Modify the fields of a task. Eg: Floating Tasks should not allow
     * modification of any sort of time.
     * 
     * @param task
     *            with the data described above.
     * @return the response message of a successful modification to the
     *         specified task.
     * @throws Exception
     */
    public String editModify(int taskID, EditTaskOption editOption) throws Exception {

        Task editedTask = _dataLog.get(taskID);
        Task oldTask = new Task(editedTask);
        String optionName = editOption.getOptionName();

        modifyTask(optionName, editedTask, editOption);
        splitTaskType(_dataLog);

        _encoder.encode();

        updateUndoLog(EDIT_MODIFY, oldTask);

        _response = String.format(MSG_EDIT_TASK_MODIFIED, editedTask.getTitle());
        return _response;
    }

    /**
     * Delete a certain task by task id.
     * 
     * @param taskID
     *            which will correspond to the index of the task in the dataLog.
     * @return the response message of a deletion of the specified task.
     * @throws Exception
     */
    public String editDelete(int taskID) throws Exception {

        Task oldTask = _dataLog.get(taskID);
        String title = _dataLog.get(taskID).getTitle();
        _dataLog.remove(taskID);
        updateID(_dataLog);

        splitTaskType(_dataLog);

        _encoder.encode();

        updateUndoLog(EDIT_DELETE, oldTask);

        _response = String.format(MSG_EDIT_TASK_DELETED, title);
        return _response;
    }

    /**
     * Clears all tasks of the specified type. Available types : CLEAR ALL,
     * CLEAR COMPLETED, CLEAR INCOMPLETE. This function is not undo-able.
     * However it will create a copy of the old data.
     * 
     * @param type
     * @return the response message of the success of clearing all of the
     *         specified tasks.
     * @throws Exception
     */
    public String editClear(String type) throws Exception {

        switch (type) {
            case CLEAR_ALL :
                _response = clearAll();
                break;
            case CLEAR_COMPLETED :
                _response = clearCompleted();
                break;
            case CLEAR_INCOMPLETE :
                _response = clearIncomplete();
                break;
            default :
                return handleException(null, MSG_ERR_INVALID_ARGUMENTS);
        }
        return _response;
    }

    /**
     * Replace an existing task of the specified taskID in the dataLog with a
     * new task.
     * 
     * @param taskID
     *            of the old task to be replaced.
     * @param newTask
     *            which will replace the specified task.
     * @return the response message of the success of replacing.
     */
    public String replace(int taskID, Task newTask) {

        Task editedTask = _dataLog.get(taskID);
        Task oldTask = new Task(editedTask);

        replaceTaskData(editedTask, newTask);

        splitTaskType(_dataLog);

        updateUndoLog(EDIT_REPLACE, oldTask);

        _response = String.format(MSG_EDIT_TASK_REPLACED, oldTask.getTitle(), newTask.getTitle());
        return _response;
    }

    /**
     * Reverses the last action under the _undoLog. Undo-able actions : addTask,
     * editModify, editDelete, editComplete, replace postpone
     * 
     * @return the response message of the success of undoing.
     * @throws Exception
     */
    public String undo() throws Exception {

        if (_undoLog.isEmpty()) {
            handleException(null, MSG_ERR_UNDO);
        }

        String undoAction = _undoLog.pop();
        Task taskObj = _undoTaskObjLog.pop();
        reverseUndo(undoAction, taskObj);

        _response = String.format(MSG_UNDO_CONFIRM, undoAction, taskObj.getTitle());
        return _response;
    }

    /**
     * Reverses the last action under the _redoLog. Redo-able actions : addTask,
     * editModify, editDelete, editComplete, replace, postpone
     * 
     * @return the response message of the success of redoing.
     * @throws Exception
     */
    public String redo() throws Exception {

        if (_redoLog.isEmpty()) {
            handleException(null, MSG_ERR_REDO);
        }

        String redoAction = _redoLog.pop();
        Task taskObj = _redoTaskObjLog.pop();
        reverseRedo(redoAction, taskObj);

        _response = String.format(MSG_REDO_CONFIRM, redoAction, taskObj.getTitle());
        return _response;
    }

    /**
     * Set a definition to a new value. Can be used to add a new definition or
     * replace an existing definition.
     * 
     * @param keyword,
     *            value
     * @return the response message of the success of setting the definition.
     * @throws Exception
     */
    public String setDefinition(String keyword, String value) throws Exception {

        if (_definitions.containsKey(keyword)) {
            _definitions.replace(keyword, value);
            _response = String.format(MSG_DEFINITION_REPLACED, keyword, value);
        } else {
            _definitions.put(keyword, value);
            _response = String.format(MSG_DEFINITION_ADDED, keyword, value);
        }

        _encoder.encode();

        return _response;
    }

    /**
     * Changes the save location of data.txt
     * 
     * @param commandDetail
     *            with the SAVE_LOCATION property.
     * @return the response message of a successful change in location.
     * @throws Exception
     */
    public String setLocation(CommandDetail commandDetail) throws Exception {

        if (commandDetail.getFilePath() == null) {
            return handleException(new IllegalArgumentException(), MSG_ERR_INVALID_ARGUMENTS);
        }

        String newSaveLocation = commandDetail.getFilePath();

        _response = _data.setPath(newSaveLocation);
        return _response;
    }

    /**
     * Postpones an event task forward or backward with reference to the new
     * input date. This edit function will preserve the duration of the event.
     * 
     * @param taskID
     * @param newDate
     *            which can be an incomplete date with either the time and/or
     *            date only.
     * @return the response message of a successful postpone of task.
     * @throws Exception
     */
    public String postpone(int taskID, KatDateTime newDate) throws Exception {

        Task editedTask = _dataLog.get(taskID);

        if (!editedTask.getTaskType().equals(TaskType.EVENT)) {
            return handleException(null, String.format(MSG_ERR_INVALID_TASK_TYPE));
        }

        // Get existing dates
        Task oldTask = new Task(editedTask);
        LocalDateTime start = editedTask.getStartDate();
        LocalDateTime end = editedTask.getEndDate();

        // Make new dates
        LocalDateTime newStartDate = autoFillDate(newDate, start);
        LocalDateTime newEndDate = addTimeDiff(start, end, newStartDate);

        if (newStartDate == null) {
            return handleException(null, MSG_ERR_INVALID_ARGUMENTS);
        }

        // Set new dates
        editedTask.setStartDate(newStartDate);
        editedTask.setEndDate(newEndDate);

        _encoder.encode();

        updateUndoLog(EDIT_POSTPONE, oldTask);

        _response = String.format(MSG_EDIT_TASK_POSTPONE, editedTask.getTitle(), editedTask.getStartDate());
        return _response;
    }

    /**
     * Imports the data.txt file from the specified location and saves it to the
     * local version. This function is not undo-able. However it will create a
     * backup of the old data.
     * 
     * @param commandDetail
     *            with the IMPORT_LOCATION property.
     * @return the response message of a successful import of data.
     * @throws Exception
     */
    public String importData(CommandDetail commandDetail) throws Exception {

        if (commandDetail.getProperty(CommandProperties.FILE_PATH) == null) {
            return handleException(new IllegalArgumentException(), MSG_ERR_INVALID_ARGUMENTS);
        }
        String importLocation = (String) commandDetail.getProperty(CommandProperties.FILE_PATH);

        createDataOld();
        _response = _data.importData(importLocation);

        _dataLog = _decoder.decode();
        splitTaskType(_dataLog);

        return _response;
    }

    public String getDataFilePath() {
        return _data.getDataFilePath();
    }

    // Get tasks data.
    public ArrayList<Task> getData() {
        return _dataLog;
    }

    public ArrayList<Task> getNormalTasks() {
        return _dataNormalTasks;
    }

    public ArrayList<Task> getFloatingTasks() {
        return _dataFloatingTasks;
    }

    public ArrayList<Task> getEventTasks() {
        return _dataEventTasks;
    }

    public Hashtable<String, String> getDefinitions() {
        return _definitions;
    }

    // Helper Methods
    private void resetRedoLog() {

        _redoLog.clear();
        _redoTaskObjLog.clear();
    }

    private void reverseUndo(String type, Task taskObj) throws Exception {

        switch (type) {
            case ADD_TASK :
                undoAdd(taskObj);
                break;
            case EDIT_MODIFY :
                undoModify(taskObj);
                break;
            case EDIT_DELETE :
                undoDelete(taskObj);
                break;
            case EDIT_COMPLETE :
                undoComplete(taskObj);
                break;
            case EDIT_REPLACE :
                undoReplace(taskObj);
                break;
            case EDIT_POSTPONE :
                undoPostpone(taskObj);
                break;
            default :
                handleException(REVERSE_EXCEPTION, MSG_ERR_REVERSE_EXCEPTION + type);
        }
    }

    private void undoAdd(Task taskObj) throws Exception {
        // Delete the added task.
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            int removeID = taskObj.getID();
            _dataLog.remove(removeID);
            updateID(_dataLog);

            splitTaskType(_dataLog);
            _encoder.encode();

            updateRedoLog(ADD_TASK, oldTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_ADD + taskObj.getTitle());
        }

    }

    private void undoModify(Task taskObj) throws Exception {
        // Delete and add back the old task
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            int removeID = taskObj.getID();
            _dataLog.remove(removeID);
            _dataLog.add(taskObj.getID(), taskObj);
            updateID(_dataLog);

            splitTaskType(_dataLog);
            _encoder.encode();

            updateRedoLog(EDIT_MODIFY, oldTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_MODIFY + taskObj.getTitle());
        }

    }

    private void undoDelete(Task taskObj) throws Exception {
        // Add back the task
        try {
            _dataLog.add(taskObj.getID(), taskObj);

            splitTaskType(_dataLog);
            _encoder.encode();

            updateRedoLog(EDIT_DELETE, taskObj);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_DELETE + taskObj.getTitle());
        }
    }

    private void undoComplete(Task taskObj) throws Exception {
        // Change task to incomplete.
        try {
            if (taskObj.isCompleted()) {
                setTaskIncomplete(taskObj);
            } else {
                setTaskComplete(taskObj);
            }

            _encoder.encode();

            updateRedoLog(EDIT_COMPLETE, taskObj);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_COMPLETE + taskObj.getTitle());
        }
    }

    private void undoReplace(Task taskObj) throws Exception {
        // Replace new task with old task
        try {
            Task newTask = _dataLog.get(taskObj.getID());
            Task redoTask = new Task(newTask);

            replaceTaskData(newTask, taskObj);

            splitTaskType(_dataLog);
            _encoder.encode();

            updateRedoLog(EDIT_REPLACE, redoTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_REPLACE + taskObj.getTitle());
        }
    }

    private void undoPostpone(Task taskObj) throws Exception {
        // Replace task with old task
        try {
            Task newTask = _dataLog.get(taskObj.getID());
            Task redoTask = new Task(newTask);

            // Replace start and end dates.
            newTask.setStartDate(taskObj.getStartDate());
            newTask.setEndDate(taskObj.getEndDate());

            _encoder.encode();

            updateRedoLog(EDIT_POSTPONE, redoTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_POSTPONE + taskObj.getTitle());
        }
    }

    private void reverseRedo(String type, Task taskObj) throws Exception {

        switch (type) {
            case ADD_TASK :
                redoAdd(taskObj);
                break;
            case EDIT_MODIFY :
                redoModify(taskObj);
                break;
            case EDIT_DELETE :
                redoDelete(taskObj);
                break;
            case EDIT_COMPLETE :
                redoComplete(taskObj);
                break;
            case EDIT_REPLACE :
                redoReplace(taskObj);
                break;
            case EDIT_POSTPONE :
                redoPostpone(taskObj);
                break;
            default :
                handleException(REVERSE_EXCEPTION, MSG_ERR_REVERSE_EXCEPTION + type);
        }
    }

    private void redoAdd(Task taskObj) throws Exception {
        // Add back the task
        try {
            _dataLog.add(taskObj.getID(), taskObj);

            splitTaskType(_dataLog);
            _encoder.encode();

            _undoLog.push(ADD_TASK);
            _undoTaskObjLog.push(taskObj);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_ADD + taskObj.getTitle());
        }

    }

    private void redoModify(Task taskObj) throws Exception {
        // Delete and add back the old task
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            int removeID = taskObj.getID();
            _dataLog.remove(removeID);
            _dataLog.add(taskObj.getID(), taskObj);
            updateID(_dataLog);

            splitTaskType(_dataLog);
            _encoder.encode();

            _undoLog.push(EDIT_MODIFY);
            _undoTaskObjLog.push(oldTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_MODIFY + taskObj.getTitle());
        }

    }

    private void redoDelete(Task taskObj) throws Exception {
        // Delete the new task
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            int removeID = taskObj.getID();
            _dataLog.remove(removeID);
            updateID(_dataLog);

            splitTaskType(_dataLog);
            _encoder.encode();

            _undoLog.push(EDIT_DELETE);
            _undoTaskObjLog.push(oldTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_DELETE + taskObj.getTitle());
        }
    }

    private void redoComplete(Task taskObj) throws Exception {
        // Change task to incomplete.
        try {
            if (taskObj.isCompleted()) {
                setTaskIncomplete(taskObj);
            } else {
                setTaskComplete(taskObj);
            }

            _encoder.encode();

            _undoLog.push(EDIT_COMPLETE);
            _undoTaskObjLog.push(taskObj);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_COMPLETE + taskObj.getTitle());
        }
    }

    private void redoReplace(Task taskObj) throws Exception {
        // Change oldTask back to new Task
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            Task undoTask = new Task(oldTask);

            replaceTaskData(oldTask, taskObj);

            splitTaskType(_dataLog);
            _encoder.encode();

            _undoLog.push(EDIT_REPLACE);
            _undoTaskObjLog.push(undoTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_REPLACE + taskObj.getTitle());
        }
    }

    private void redoPostpone(Task taskObj) throws Exception {
        // Replace old task with redo task
        try {
            Task oldTask = _dataLog.get(taskObj.getID());
            Task undoTask = new Task(oldTask);

            // Replace start and end dates.
            oldTask.setStartDate(taskObj.getStartDate());
            oldTask.setEndDate(taskObj.getEndDate());

            _encoder.encode();

            _undoLog.push(EDIT_POSTPONE);
            _undoTaskObjLog.push(undoTask);

        } catch (Exception e) {
            handleException(e, MSG_ERR_REVERSE_POSTPONE + taskObj.getTitle());
        }
    }

    /**
     * Add new definitions here. Initialises the definitions table with default
     * keywords. Runs before decoding.
     */
    private void initDefinitions() {

        _definitions = new Hashtable<String, String>();
        _definitions.put("morning", MORNING);
        _definitions.put("afternoon", AFTERNOON);
        _definitions.put("evening", EVENING);
        _definitions.put("night", NIGHT);
    }

    private LocalDateTime autoFillDate(KatDateTime incompleteDate, LocalDateTime referenceDate) {

        if (!incompleteDate.hasDate() && !incompleteDate.hasTime()) {
            return null;
        }
        if (!incompleteDate.hasDate()) {
            incompleteDate.changeDate(referenceDate.toLocalDate());
        } else if (!incompleteDate.hasTime()) {
            incompleteDate.changeTime(referenceDate.toLocalTime());
        }

        return incompleteDate.toLocalDateTime();
    }

    private LocalDateTime addTimeDiff(LocalDateTime start, LocalDateTime end, LocalDateTime newStart) {

        LocalDateTime newEnd = newStart;

        long years = start.until(end, ChronoUnit.YEARS);
        newEnd = newEnd.plusYears(years);

        long months = start.until(end, ChronoUnit.MONTHS);
        newEnd = newEnd.plusMonths(months);

        long days = start.until(end, ChronoUnit.DAYS);
        newEnd = newEnd.plusDays(days);

        long hours = start.until(end, ChronoUnit.HOURS);
        newEnd = newEnd.plusHours(hours);

        long minutes = start.until(end, ChronoUnit.MINUTES) % 60;
        newEnd = newEnd.plusMinutes(minutes);

        return newEnd;
    }

    private void splitTaskType(Task task) {
        TaskType type = task.getTaskType();
        switch (type) {
            case NORMAL :
                _dataNormalTasks.add(task);
                break;
            case FLOATING :
                _dataFloatingTasks.add(task);
                break;
            case EVENT :
                _dataEventTasks.add(task);
                break;
            default :
                _dataNormalTasks.add(task);
                break;
        }
    }

    private void splitTaskType(ArrayList<Task> taskArray) {

        // Reset
        _dataNormalTasks = new ArrayList<Task>();
        _dataFloatingTasks = new ArrayList<Task>();
        _dataEventTasks = new ArrayList<Task>();

        TaskType type;
        for (Task t : taskArray) {
            type = t.getTaskType();
            switch (type) {
                case NORMAL :
                    _dataNormalTasks.add(t);
                    break;
                case FLOATING :
                    _dataFloatingTasks.add(t);
                    break;
                case EVENT :
                    _dataEventTasks.add(t);
                    break;
                default :
                    _dataNormalTasks.add(t);
                    break;
            }
        }
    }

    private void modifyTask(String optionName, Task editedTask, EditTaskOption editOption) throws Exception {

        switch (optionName) {
            // case CommandProperties.TASK_ID :
            // handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
            case CommandProperties.TASK_TITLE :
                editedTask.setTitle(editOption.getOptionValue());
                break;
            case CommandProperties.TIME_FROM :
                startDateEdit(editedTask, editOption);
                break;
            case CommandProperties.TIME_BY :
            case CommandProperties.TIME_TO :
                dueDateEdit(editedTask, editOption);
                break;
            // case CommandProperties.TIME_REPEAT :
            // handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
            // editedTask.setRepeatOption(editOption.getOptionValue());
            // break;
            // case CommandProperties.TIME_UNTIL :
            // handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
            // editedTask.setTerminateDate(editOption.getOptionValueDate());
            // break;
            // case CommandProperties.TASK_DESCRIPTION :
            // handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
            // editedTask.setDescription(editOption.getOptionValue());
            // break;
            // case CommandProperties.TASK_CATEGORY :
            // handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
            // editedTask.setCategory(editOption.getOptionValue());
            // break;
            default :
                handleException(null, MSG_ERR_TASK_NOT_MODIFIED);
        }
    }

    private void startDateEdit(Task editedTask, EditTaskOption editOption) throws Exception {

        if (editedTask.getTaskType().equals(TaskType.FLOATING)) {
            handleException(null, MSG_ERR_INVALID_MODIFICATION);
        } else if (editedTask.getTaskType().equals(TaskType.NORMAL)) {
            editedTask.setTaskType(TaskType.EVENT);
            editedTask.setStartDate(LocalDateTime.now());
        }

        LocalDateTime newStartDate = DateTimeUtils.updateDateTime(editedTask.getStartDate(),
                editOption.getOptionValueDate());

        if (editedTask.getEndDate().isBefore(newStartDate)) {
            handleException(null, MSG_ERR_START_AFTER_END);
        }

        editedTask.setStartDate(newStartDate);
    }

    private void dueDateEdit(Task editedTask, EditTaskOption editOption) {

        if (editedTask.getTaskType().equals(TaskType.FLOATING)) {
            editedTask.setTaskType(TaskType.NORMAL);
            editedTask.setEndDate(LocalDateTime.now());
        }
        editedTask.setEndDate(editOption.getOptionValueDate());
    }

    private void replaceTaskData(Task dest, Task src) {

        dest.setTitle(src.getTitle());
        dest.setTaskType(src.getTaskType());
        dest.setStartDate(src.getStartDate());
        dest.setEndDate(src.getEndDate());
        dest.setRepeatOption(src.getRepeatOption());
        dest.setTerminateDate(src.getTerminateDate());
        dest.setDescription(src.getDescription());
        dest.setCategory(src.getCategory());
        dest.setCompleted(src.isCompleted());
    }

    private void createDataOld() throws Exception {

        _data.createBackup();
    }

    private int getNextID() {
        return _dataLog.size();
    }

    private void updateID(ArrayList<Task> taskArray) {
        // Update the id-field for the tasks on each shift.
        for (int i = 0; i < taskArray.size(); i++) {
            Task updateTask = taskArray.get(i);
            updateTask.setID(i);
        }
    }

    private String clearAll() throws Exception {

        createDataOld();
        _dataLog.clear();
        splitTaskType(_dataLog);
        _encoder.encode();

        return MSG_EDIT_TASK_CLEAR_ALL;
    }

    private String clearCompleted() throws Exception {

        createDataOld();
        for (Task t : _dataLog) {
            if (t.isCompleted()) {
                _dataLog.remove(t);
            }
        }
        splitTaskType(_dataLog);
        _encoder.encode();

        return MSG_EDIT_TASK_CLEAR_COMPLETED;
    }

    private String clearIncomplete() throws Exception {

        createDataOld();
        for (Task t : _dataLog) {
            if (!t.isCompleted()) {
                _dataLog.remove(t);
            }
        }
        splitTaskType(_dataLog);
        _encoder.encode();

        return MSG_EDIT_TASK_CLEAR_INCOMPLETE;
    }

    private void updateUndoLog(String type, Task taskObj) {
        _undoLog.push(type);
        _undoTaskObjLog.push(taskObj);
        resetRedoLog();
    }

    private void updateRedoLog(String type, Task taskObj) {
        _redoLog.push(type);
        _redoTaskObjLog.push(taskObj);
    }

    private void setTaskComplete(Task taskObj) {
        taskObj.setCompleted(true);
    }

    private void setTaskIncomplete(Task taskObj) {
        taskObj.setCompleted(false);
    }

    /**
     * Reserved for Unit Testing only. Runs the decoder.
     * 
     * @throws Exception
     */
    public ArrayList<Task> testDecode() throws Exception {
        return _decoder.decode();
    }

    private String handleException(Exception e, String msg) throws Exception {

        if (e == null) {
            throw new Exception(msg);
        } else {
            throw new Exception(e.getMessage() + " - " + msg);
        }
    }

    // Sub Classes

    /**
     * This helper class runs upon creation. It will search for the data.txt
     * file and decode the data within into the application memory for
     * modifications.
     * 
     * @author sk
     *
     */
    class StorageDecoder {

        // Private variables

        // Constructor
        public StorageDecoder() throws Exception {

        }

        public ArrayList<Task> decode() throws Exception {

            // Setup Environment
            String[] headerTokens;
            ArrayList<Task> taskArray = new ArrayList<Task>();
            String line;

            BufferedReader bReader = new BufferedReader(new FileReader(_data.getDataFilePath()));

            // Read through data.txt
            while ((line = bReader.readLine()) != null && !line.equals(MSG_LOG_START)) {
                // Read header data. Till <start>
                headerTokens = line.split(" ");
                interpret(headerTokens);
            }

            while ((line = bReader.readLine()) != null) {
                Task newTask = parseLineToTask(line);
                taskArray.add(newTask);
            }

            // Finished decoding data.txt, close reader.
            bReader.close();

            // return taskArray
            return taskArray;
        }

        // Helper Method
        private void interpret(String[] tokenArray) {

            // Add Definitions to hash table.
            if (tokenArray.length < 1) {
                // Discard
                return;
            } else {
                String keyword = tokenArray[0];
                String value = tokenArray[1];
                if (_definitions.containsKey(keyword)) {
                    _definitions.replace(keyword, value);
                } else {
                    _definitions.put(keyword, value);
                }
            }
        }

        @SuppressWarnings({ "rawtypes", "unchecked" })
        private Task parseLineToTask(String line) throws Exception {

            // Setup Environment
            String jsonText = line;
            JSONParser parser = new JSONParser();
            ContainerFactory containerFactory = new ContainerFactory() {
                public List creatArrayContainer() {
                    return new LinkedList();
                }

                public Map createObjectContainer() {
                    return new LinkedHashMap();
                }
            };
            Task newTask = null;
            try {
                // Push parse details to JSONArray
                Map jsonMap = (Map) parser.parse(jsonText, containerFactory);
                JSONArray array = new JSONArray();
                array.add(jsonMap.get(KEY_ID));
                array.add(jsonMap.get(KEY_TITLE));
                array.add(jsonMap.get(KEY_TASK_TYPE));
                array.add(jsonMap.get(KEY_START_DATE));
                array.add(jsonMap.get(KEY_END_DATE));
                array.add(jsonMap.get(KEY_REPEAT_OPTION));
                array.add(jsonMap.get(KEY_TERMINATE_DATE));
                array.add(jsonMap.get(KEY_DESCRIPTION));
                array.add(jsonMap.get(KEY_CATEGORY));
                array.add(jsonMap.get(KEY_COMPLETED));

                // Create new Task and return
                newTask = new Task();
                setupTaskData(newTask, array);
                return newTask;

            } catch (Exception e) {
                handleException(e, MSG_ERR_JSON_PARSE_ERROR);
            }

            return newTask;
        }

        private void setupTaskData(Task task, JSONArray array) throws Exception {
            String[] args = new String[TASK_ARG_SIZE];
            for (int i = 0; i < TASK_ARG_SIZE; i++) {
                args[i] = (String) array.get(i);
            }
            try {
                task.setID(Integer.parseInt(args[INDEX_ID]));
                task.setTitle(args[INDEX_TITLE]);
                if (args[INDEX_TASK_TYPE] != null) {
                    switch (args[INDEX_TASK_TYPE]) {
                        case "EVENT" :
                            task.setTaskType(TaskType.EVENT);
                            break;
                        case "FLOATING" :
                            task.setTaskType(TaskType.FLOATING);
                            break;
                        case "NORMAL" :
                        default :
                            task.setTaskType(TaskType.NORMAL);
                    }
                }
                task.setStartDate(stringToDate(args[INDEX_START_DATE]));
                task.setEndDate(stringToDate(args[INDEX_END_DATE]));
                task.setRepeatOption(args[INDEX_REPEAT_OPTION]);
                task.setTerminateDate(stringToDate(args[INDEX_TERMINATE_DATE]));
                task.setDescription(args[INDEX_DESCRIPTION]);
                task.setCategory(args[INDEX_CATEGORY]);
                task.setCompleted(stringToBool(args[INDEX_COMPLETED]));
            } catch (Exception e) {
                throw new Exception(MSG_ERR_PARSE_EXCEPTION + e);
            }
        }

        private LocalDateTime stringToDate(String dateStr) throws ParseException {
            if (dateStr.equals(NULL_DATE)) {
                return null;
            } else {
                LocalDateTime date = LocalDateTime.parse(dateStr, DateTimeFormatter.ISO_DATE_TIME);
                return date;
            }
        }

        private Boolean stringToBool(String bool) {
            if (bool.equals(STR_TRUE)) {
                return true;
            } else {
                return false;
            }
        }
    }

    /**
     * This helper class runs after each modification (By default: Auto-save
     * after each action). It will encode the modified version of the
     * application memory (_data) into the data.txt file.
     * 
     * @author sk
     *
     */
    class StorageEncoder {

        // Private Variables
        Integer _id;

        // Constructor
        public StorageEncoder() {

        }

        public void encode() throws Exception {

            // Setup environment
            ArrayList<Task> taskArray = _dataLog;
            _id = 0;

            PrintWriter pWriter = createNewDataLog(_data.getDataFilePath());
            // Print all definitions before <start>
            for (String keyword : _definitions.keySet()) {
                pWriter.println(keyword + " " + _definitions.get(keyword));
            }
            pWriter.println(MSG_LOG_START);

            // Iterate through Log
            for (Task t : taskArray) {
                pWriter.println(getJSONTaskString(t));
                _id++;
            }

            pWriter.close();
            // Encoding done. Data saved.
        }

        private PrintWriter createNewDataLog(String path) throws Exception {

            File dataFile = new File(path);

            try {
                if (!dataFile.exists()) {
                    // Should not happen; Recovery.
                    dataFile.createNewFile();
                }
                PrintWriter pWriter = new PrintWriter(dataFile);
                return pWriter;

            } catch (Exception e) {
                throw new Exception(e);
            }
        }

        @SuppressWarnings("unchecked")
        private String getJSONTaskString(Task t) {

            Map taskMap = new LinkedHashMap();
            taskMap.put(KEY_ID, _id.toString());
            taskMap.put(KEY_TITLE, t.getTitle());
            taskMap.put(KEY_TASK_TYPE, typeToString(t.getTaskType()));
            taskMap.put(KEY_START_DATE, dateToString(t.getStartDate()));
            taskMap.put(KEY_END_DATE, dateToString(t.getEndDate()));
            taskMap.put(KEY_REPEAT_OPTION, t.getRepeatOption());
            taskMap.put(KEY_TERMINATE_DATE, dateToString(t.getTerminateDate()));
            taskMap.put(KEY_DESCRIPTION, t.getDescription());
            taskMap.put(KEY_CATEGORY, t.getCategory());
            taskMap.put(KEY_COMPLETED, boolToString(t.isCompleted()));
            String jsonText = JSONValue.toJSONString(taskMap);
            return jsonText;
        }

        // Helper Methods
        private String typeToString(TaskType taskType) {

            String type;

            if (taskType == null) {
                return null;
            }
            switch (taskType) {
                case NORMAL :
                    type = TYPE_NORMAL;
                    break;
                case FLOATING :
                    type = TYPE_FLOATING;
                    break;
                case EVENT :
                    type = TYPE_EVENT;
                    break;
                default :
                    return TYPE_NORMAL;
            }

            return type;
        }

        private String dateToString(LocalDateTime date) {
            if (date == null) {
                return NULL_DATE;
            } else {
                String dateStr = date.format(DATE_FORMATTER);
                return dateStr;
            }
        }

        private String boolToString(boolean bool) {
            if (bool) {
                return STR_TRUE;
            } else {
                return STR_FALSE;
            }
        }
    }

    /**
     * This helper class will store the location of the data.txt and related
     * functionalities.
     * 
     * @author sk
     *
     */
    class StorageData {

        private static final int CHARCODE_BACKSLASH = 92;

        // Private Variables
        private String _sourcePath;
        private String _dataFilePath;

        // Constructor
        public StorageData(String path) throws Exception {

            _sourcePath = path;
            _dataFilePath = path + DATA_FILENAME;
            _response = createFiles();
            // System.out.println(_response);
        }

        // Get
        public String getPath() {

            return _sourcePath;
        }

        public String getDataFilePath() {

            return _dataFilePath;
        }

        // Set
        public String setPath(String newPath) throws Exception {

            newPath = validateLocation(newPath);

            _response = migrateData(_sourcePath + DATA_FILENAME, newPath + DATA_FILENAME);
            _sourcePath = newPath;
            _dataFilePath = newPath + DATA_FILENAME;
            return _response;
        }

        // Import
        public String importData(String importLocation) throws Exception {

            importLocation = validateLocation(importLocation);

            // Look for data.txt in importLocation
            String importFilePath = importLocation + DATA_FILENAME;
            File importFile = new File(importFilePath);
            if (!importFile.exists()) {
                return handleException(null, MSG_ERR_IMPORT_LOCATION_MISSING);
            }

            // Import data over. (Overwrite onto existing)
            File dataFile = new File(_dataFilePath);
            if (dataFile.exists()) {
                dataFile.delete();
            }
            copyData(importFilePath, _dataFilePath);

            _response = String.format(MSG_IMPORT_CONFIRM, importFilePath, _dataFilePath);
            return _response;
        }

        // Create Backup data
        public void createBackup() throws Exception {

            File currentData = new File(_sourcePath + DATA_FILENAME);
            File backupData = new File(_sourcePath + DATA_BACKUP_FILENAME);

            if (!currentData.exists()) {
                return;
            }

            if (backupData.exists()) {
                backupData.delete();
            }
            backupData.createNewFile();

            copyData(currentData.getPath(), backupData.getPath());
        }

        // Helper Methods
        private String createFiles() throws Exception {

            try {
                // Create data file.
                File dataFile = new File(_sourcePath + DATA_FILENAME);
                if (!dataFile.exists()) {
                    dataFile.createNewFile();
                }
                return String.format(MSG_DATA_FILE_READY, dataFile.getPath());
            } catch (IOException e) {
                return handleException(e, MSG_ERR_IO);
            }
        }

        private String migrateData(String oldLoc, String newLoc) throws Exception {

            // Execute
            try {
                File oldFile = new File(oldLoc);
                File newFile = new File(newLoc);

                if (!oldFile.exists()) {
                    return handleException(null, MSG_ERR_MISSING_DATA);
                }

                newFile.createNewFile();
                FileInputStream inStream = new FileInputStream(oldFile);
                FileOutputStream outStream = new FileOutputStream(newFile);

                byte[] buffer = new byte[MAX_BUFFER_SIZE];

                int length;
                // copy the file content in bytes
                while ((length = inStream.read(buffer)) > 0) {
                    outStream.write(buffer, 0, length);
                }

                inStream.close();
                outStream.close();

                // delete the original file
                oldFile.delete();

                return String.format(MSG_MIGRATE_CONFIRM, oldLoc, newLoc);

            } catch (IOException e) {
                return handleException(e, MSG_ERR_IO);
            }
        }

        private void copyData(String src, String dest) throws Exception {

            try {
                File srcFile = new File(src);
                File destFile = new File(dest);

                destFile.createNewFile();
                FileInputStream inStream = new FileInputStream(srcFile);
                FileOutputStream outStream = new FileOutputStream(destFile);

                byte[] buffer = new byte[MAX_BUFFER_SIZE];

                int length;
                while ((length = inStream.read(buffer)) > 0) {
                    outStream.write(buffer, 0, length);
                }

                inStream.close();
                outStream.close();

            } catch (IOException e) {
                handleException(e, MSG_ERR_IO);
            }
        }

        private String validateLocation(String input) {

            char lastChar = input.charAt(input.length() - 1);
            if (lastChar != CHARCODE_BACKSLASH) {
                input = input + '\\';
            }

            return input;
        }
    }
}
```
###### src\test\TestModel.java
``` java
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;

import katnote.Model;
import katnote.command.CommandDetail;
import katnote.command.CommandProperties;
import katnote.parser.EditTaskOption;
import katnote.task.Task;
import katnote.task.TaskType;
import katnote.utils.KatDateTime;

import org.junit.Test;

public class TestModel {

    // Constants
    private static final String DATA_FILENAME = "data.txt";
    private static final String DATA_BACKUP_FILENAME = "dataOld.txt";
    private static final String TEST_PATH = "TestFiles/TestModel/";
    private static final String TEST_PATH_ADDTASK = "TestFiles/TestModel/addTaskExpected.txt";
    private static final String TEST_PATH_SETDEFINITION = "TestFiles/TestModel/setDefinitionExpected.txt";
    private static final String TEST_PATH_SETLOCATION = "TestFiles/TestModel/setLocationExpected.txt";
    private static final String TEST_PATH_POSTPONE = "TestFiles/TestModel/postponeExpected.txt";
    private static final String TEST_PATH_UNDOREDO = "TestFiles/TestModel/undoredoExpected.txt";

    // Messages
    private static final String MSG_ERR_IO = "I/O Exception.";
    private static final String MSG_ERR_MISSING_FILE = "Missing File: ";

    // Dates
    private static final LocalDateTime TODAY = LocalDateTime.now();

    /**
     * Compare the contents of both text files.
     * 
     * @param actual
     * @param expected
     * @return true if both files are the same in content and false if
     *         otherwise.
     * @throws Exception
     */
    public boolean compareFile(String actual, String expected) throws Exception {

        File actualFile = new File(actual);
        File expectedFile = new File(expected);

        if (!actualFile.exists()) {
            handleException(new FileNotFoundException(), MSG_ERR_MISSING_FILE + actual);
        }
        if (!expectedFile.exists()) {
            handleException(new FileNotFoundException(), MSG_ERR_MISSING_FILE + expected);
        }

        BufferedReader readerActual = new BufferedReader(new FileReader(actualFile));
        BufferedReader readerExpected = new BufferedReader(new FileReader(expectedFile));

        ArrayList<String> contentActual = new ArrayList<String>();
        ArrayList<String> contentExpected = new ArrayList<String>();

        String line;

        try {
            while ((line = readerActual.readLine()) != null) {
                contentActual.add(line);
            }

            while ((line = readerExpected.readLine()) != null) {
                contentExpected.add(line);
            }
        } catch (IOException e) {
            handleException(e, MSG_ERR_IO);
        }

        readerActual.close();
        readerExpected.close();

        if (contentActual.size() != contentExpected.size()) {
            System.err.println("Different content length!");
            return false;
        }

        for (int i = 0; i < contentActual.size(); i++) {
            if (!contentActual.get(i).equals(contentExpected.get(i))) {
                System.err.println("Mismatch on line: " + (i + 1));
                System.err.println("Actual Line = " + contentActual.get(i));
                return false;
            }
        }

        return true;
    }

    private String handleException(Exception e, String msg) throws Exception {
        throw new Exception(e + " - " + msg);
    }

    /**
     * Usage: (title, taskType, start, end, due)
     * 
     * @param title
     * @param taskType
     * @param start
     * @param end
     * @param due
     * @return the task object.
     */
    private CommandDetail createTask(String title, TaskType taskType, KatDateTime start, KatDateTime end,
            KatDateTime due) {

        CommandDetail cmd = new CommandDetail();
        if (!title.isEmpty()) {
            cmd.setProperty(CommandProperties.TASK_TITLE, title);
        }
        if (taskType != null) {
            cmd.setProperty(CommandProperties.TASK_TYPE, taskType);
        }
        if (start != null) {
            cmd.setProperty(CommandProperties.TIME_FROM, start);
        }
        if (end != null) {
            cmd.setProperty(CommandProperties.TIME_TO, end);
        }
        if (due != null) {
            cmd.setProperty(CommandProperties.TIME_BY, due);
        }
        return cmd;
    }

    private void clearExistingData(String path) {

        File clearData = new File(path + DATA_FILENAME);
        if (clearData.exists()) {
            clearData.delete();
        }

        File clearDataOld = new File(path + DATA_BACKUP_FILENAME);
        if (clearData.exists()) {
            clearData.delete();
        }
    }

    // ACTUAL TESTS

    @Test
    public void testSetLocation() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Set Save Location ===");
            String newPath = "TestFiles/NewTestModel/";

            Model testModel = new Model(TEST_PATH);
            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2015, 11, 26, 23, 59, 59));
            CommandDetail addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            Task task1 = new Task(addTaskCmd1);
            CommandDetail testCmd = new CommandDetail();
            testCmd.setProperty(CommandProperties.FILE_PATH, "invalidLocation");

            boolean result4 = true;
            try {
                testModel.setLocation(testCmd);
            } catch (Exception e) {
                result4 = false;
            }

            testCmd.setProperty(CommandProperties.FILE_PATH, newPath);

            testModel.addTask(task1);

            testModel.setLocation(testCmd);

            File newFile = new File(newPath + DATA_FILENAME);
            File oldFile = new File(TEST_PATH + DATA_FILENAME);

            boolean result3 = compareFile(testModel.getDataFilePath(), TEST_PATH_SETLOCATION);

            System.out.println("Result 1 - New File exist: " + newFile.exists() + " Expected: true");
            System.out.println("Result 2 - Old File exist: " + oldFile.exists() + " Expected: false");
            System.out.println("Result 3 - New File contents are correct: " + result3 + "Expected: true");
            System.out.println("Result 4 - Set location to invalid location: " + result4 + "Expected: false");
            boolean result1 = newFile.exists();
            boolean result2 = oldFile.exists();

            // Clean up
            if (newFile.exists()) {
                newFile.delete();
            }
            System.out.println("=== End Test ===\n");

            assertTrue(result1);
            assertFalse(result2);
            assertTrue(result3);
            assertFalse(result4);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }
    }

    @Test
    public void testAddTask() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Add Task ===");
            Model testModel = new Model(TEST_PATH);
            CommandDetail addTaskCmd1;
            CommandDetail addTaskCmd2;

            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2015, 10, 23, 23, 59));
            // System.out.println("Date Field: " +
            // date1.format(DATE_FORMATTER));

            addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            Task task1 = new Task(addTaskCmd1);
            addTaskCmd2 = createTask("  ", TaskType.FLOATING, null, null, null);
            Task task2 = new Task(addTaskCmd2);

            testModel.addTask(task1);
            testModel.addTask(task2);

            boolean result = compareFile(testModel.getDataFilePath(), TEST_PATH_ADDTASK);

            // Clean Up
            clearExistingData(TEST_PATH);
            System.out.println("Result 1 - Tasks Added Correctly: " + result + " Expected: true");
            System.out.println("=== End Test ===\n");

            assertTrue(result);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }
    }

    @Test
    public void testSetDefinition() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Add Task ===");
            Model testModel = new Model(TEST_PATH);

            testModel.setDefinition("night", "10.30pm");
            testModel.setDefinition("afternoon", "2.00pm");
            testModel.setDefinition("morning", "8.00am");
            testModel.setDefinition("sleeptime", "11.00pm");
            testModel.setDefinition("wakeup", "7.30am");
            testModel.setDefinition("evening", "7.30pm");

            boolean result = compareFile(testModel.getDataFilePath(), TEST_PATH_SETDEFINITION);

            // Clean Up
            clearExistingData(TEST_PATH);
            System.out.println("Result 1 - Definitions set correctly: " + result + " Expected: true");
            System.out.println("=== End Test ===\n");

            assertTrue(result);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }
    }

    @Test
    public void testImportLocation() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Import ===");
            Model testModel = new Model(TEST_PATH);
            CommandDetail importCmd = new CommandDetail();
            boolean result1 = false;
            String importPath1 = "TestFiles/ImportLoc/";
            importCmd.setProperty(CommandProperties.FILE_PATH, importPath1);

            testModel.importData(importCmd);

            File fileToImport = new File(importPath1 + DATA_FILENAME);
            File importedFile = new File(TEST_PATH + DATA_FILENAME);

            System.out.println("FileToImport exist: " + fileToImport.exists());
            System.out.println("ImportedFile exist: " + importedFile.exists());

            if (fileToImport.exists() && importedFile.exists()) {
                result1 = compareFile(fileToImport.getPath(), importedFile.getPath());
            }

            clearExistingData(TEST_PATH);

            boolean result2 = false;
            String importPath2 = "TestFiles/ImportLocBlank/";
            importCmd.setProperty(CommandProperties.FILE_PATH, importPath2);

            try {
                testModel.importData(importCmd);
            } catch (Exception e) {
                result2 = true;
            }

            System.out.println("Result 1 - File imported correctly: " + result1 + " Expected: true");
            System.out.println("Result 2 - Blank File not imported: " + result2 + " Expected: true");
            System.out.println("=== End Test ===\n");

            clearExistingData(TEST_PATH);

            assertTrue(result1);
            assertTrue(result2);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }

    }

    @Test
    public void testDeleteTask() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Delete Task ===");
            Model testModel = new Model(TEST_PATH);
            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2015, 11, 26, 23, 59, 59));
            KatDateTime date2 = new KatDateTime(LocalDateTime.of(2015, 12, 23, 23, 59, 59));
            CommandDetail addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            CommandDetail addTaskCmd2 = createTask("feed fish", TaskType.NORMAL, null, null, date2);
            CommandDetail addTaskCmd3 = createTask("feed dog", TaskType.FLOATING, null, null, null);
            Task task1 = new Task(addTaskCmd1);
            Task task2 = new Task(addTaskCmd2);
            Task task3 = new Task(addTaskCmd3);
            String response1;
            String response2;

            testModel.addTask(task1);
            testModel.addTask(task2);
            testModel.addTask(task3);

            boolean result1 = false;
            boolean result2 = false;
            boolean result3 = false;

            response1 = testModel.editDelete(1);
            result1 = response1.equals("Task: feed fish is successfully deleted.")
                    && (testModel.getData().size() == 2);

            response2 = testModel.editDelete(1);
            try {
                testModel.editDelete(1);
            } catch (IndexOutOfBoundsException e) {
                result3 = true;
            }

            result2 = response2.equals("Task: feed dog is successfully deleted.")
                    && (testModel.getData().size() == 1);

            System.out.println("Result 1 - Task deleted correctly: " + result1 + " Expected: true");
            System.out.println("Result 2 - Task updates after delete and delete works correctly: " + result2
                    + " Expected: true");
            System.out.println(
                    "Result 3 - Delete recognises incorrect delete command: " + result3 + " Expected: true");
            System.out.println("=== End Test ===\n");

            clearExistingData(TEST_PATH);

            assertTrue(result1);
            assertTrue(result2);
            assertTrue(result3);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }

    }

    @Test
    public void testEncodeDecode() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Encoding and Decoding ===");
            Model testModel = new Model(TEST_PATH);
            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2015, 11, 26, 23, 59, 59));
            KatDateTime date2 = new KatDateTime(LocalDateTime.of(2015, 12, 23, 23, 59, 59));
            CommandDetail addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            CommandDetail addTaskCmd2 = createTask("feed fish", TaskType.NORMAL, null, null, date2);
            CommandDetail addTaskCmd3 = createTask("feed dog", TaskType.FLOATING, null, null, null);
            Task task1 = new Task(addTaskCmd1);
            Task task2 = new Task(addTaskCmd2);
            Task task3 = new Task(addTaskCmd3);

            testModel.addTask(task1);
            testModel.addTask(task2);
            testModel.addTask(task3);

            boolean result1 = false;

            try {
                ArrayList<Task> decodedData = testModel.testDecode();
                result1 = true;
                System.out.println("Actual Data Size: " + decodedData.size() + " Expected Data Size: "
                        + testModel.getData().size());
                if (decodedData.size() != testModel.getData().size()) {
                    result1 = false;
                }
                for (int i = 0; i < decodedData.size(); i++) {
                    System.out.println("Actual Item " + i + " : " + decodedData.get(i).getTitle()
                            + " Expected Item " + i + " : " + testModel.getData().get(i).getTitle());
                    if (!decodedData.get(i).getTitle().equals(testModel.getData().get(i).getTitle())) {
                        result1 = false;
                    }
                }
            } catch (Exception e) {
                System.err.println("Unable to decode: " + e);
            }

            System.out.println(
                    "Result 1 - KatNote encodes and decodes successfully: " + result1 + " Expected: true");
            System.out.println("=== End Test ===\n");

            clearExistingData(TEST_PATH);

            assertTrue(result1);

        } catch (Exception e) {
            System.out.println(e);
            fail("Exception!");
        }

    }

    @Test
    public void testUndoRedo() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Undo and Redo ===");
            Model testModel = new Model(TEST_PATH);
            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2015, 11, 26, 23, 59, 59));
            KatDateTime date2 = new KatDateTime(LocalDateTime.of(2015, 12, 23, 23, 59, 59));
            KatDateTime date3 = new KatDateTime(LocalDateTime.of(2015, 12, 10, 12, 00));
            CommandDetail addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            CommandDetail addTaskCmd2 = createTask("feed fish", TaskType.NORMAL, null, null, date2);
            CommandDetail addTaskCmd3 = createTask("feed dog", TaskType.FLOATING, null, null, null);
            CommandDetail addTaskCmd4 = createTask("feed dog", TaskType.EVENT, date1, date2, null);
            Task task1 = new Task(addTaskCmd1);
            Task task2 = new Task(addTaskCmd2);
            Task task3 = new Task(addTaskCmd3);
            Task task4 = new Task(addTaskCmd4);

            testModel.addTask(task1);
            testModel.addTask(task2);
            testModel.addTask(task3);

            boolean result1 = false;
            boolean result2 = false;
            boolean result3 = false;
            boolean result4 = false;
            boolean result5 = true;
            boolean result6;

            // Procedure
            testModel.undo();

            testModel.undo();

            if (!testModel.getData().get(0).getTitle().equals(task1.getTitle())) {
                System.err.println("Undo procedure is incorrect. Incorrect task undone.");
                result1 = false;
            } else {
                result1 = true;
            }

            testModel.undo();
            try {
                testModel.undo();
            } catch (Exception e) {
                result2 = true;
            }

            testModel.redo();
            if ((testModel.getData().size() != 1)
                    || (!testModel.getData().get(0).getTitle().equals(task1.getTitle()))) {
                System.err.println("Redo procedure is incorrect. Incorrect task redone.");
                result3 = false;
            } else {
                result3 = true;
            }

            testModel.redo();
            testModel.redo();

            try {
                testModel.redo();
            } catch (Exception e1) {

                testModel.undo();
                testModel.addTask(task3);

                try {
                    testModel.redo();
                } catch (Exception e2) {
                    result4 = true;
                }
            }

            testModel.editDelete(1);
            testModel.editDelete(1);
            testModel.addTask(task2);
            testModel.addTask(task3);
            testModel.undo();
            testModel.undo();
            testModel.redo();
            testModel.undo();
            testModel.redo();
            testModel.redo();
            if (testModel.getData().size() != 3) {
                System.err.println("Redo + Undo procedure is incorrect. Actual Tasks left: "
                        + testModel.getData().size() + " Expected Tasks Left: " + 3);
                result5 = false;
            } else if (!testModel.getData().get(2).getTitle().equals(task3.getTitle())) {
                System.err.println("Redo + Undo procedure is incorrect. Actual task(2): "
                        + testModel.getData().get(2).getTitle() + " Expected task(2): " + task3.getTitle());
                result5 = false;
            }

            EditTaskOption option1 = new EditTaskOption(CommandProperties.TASK_TITLE, "New Title");
            EditTaskOption option2 = new EditTaskOption(CommandProperties.TIME_BY, "28/11 2am");

            testModel.editComplete(0);

            testModel.editModify(0, option1);

            testModel.addTask(task4);

            testModel.editModify(3, option2);

            testModel.postpone(3, date3);

            testModel.editDelete(2);

            testModel.undo();
            testModel.undo();
            testModel.undo();
            testModel.undo();
            testModel.undo();
            testModel.undo();

            testModel.redo();
            testModel.redo();
            testModel.redo();
            testModel.redo();
            testModel.redo();
            testModel.redo();

            result6 = compareFile(testModel.getDataFilePath(), TEST_PATH_UNDOREDO);

            System.out.println("Result 1 - Undo Test 1: " + result1 + " Expected: true");
            System.out.println("Result 2 - Undo Test 2: " + result2 + " Expected: true");
            System.out.println("Result 3 - Redo Test 1: " + result3 + " Expected: true");
            System.out.println("Result 4 - Redo Test 2: " + result4 + " Expected: true");
            System.out.println("Result 5 - Undo + Redo Test 1: " + result5 + " Expected: true");
            System.out.println("Result 6 - Undo + Redo Test 2: " + result6 + " Excepted: true");
            System.out.println("=== End Test ===\n");

            clearExistingData(TEST_PATH);

            assertTrue(result1);
            assertTrue(result2);
            assertTrue(result3);
            assertTrue(result4);
            assertTrue(result5);
            assertTrue(result6);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }

    }

    @Test
    public void testPostpone() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Postpone ===");
            Model testModel = new Model(TEST_PATH);
            CommandDetail addTaskCmd1;
            CommandDetail addTaskCmd2;
            CommandDetail addTaskCmd3;
            CommandDetail addTaskCmd4;
            CommandDetail addTaskCmd5;
            CommandDetail addTaskCmd6;

            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2016, 10, 23, 23, 59));
            KatDateTime date2 = new KatDateTime(LocalDateTime.of(2016, 10, 25, 23, 59));
            KatDateTime date3 = new KatDateTime(LocalDateTime.of(2016, 10, 26, 23, 59));
            KatDateTime date4 = new KatDateTime(LocalDateTime.of(2017, 11, 28, 23, 59));
            KatDateTime date5 = new KatDateTime(LocalDateTime.of(2016, 10, 29, 23, 59));
            KatDateTime date6 = new KatDateTime(LocalDateTime.of(2016, 10, 28, 22, 59));
            KatDateTime date7 = new KatDateTime(LocalDateTime.of(2016, 10, 28, 21, 00));

            addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            Task task1 = new Task(addTaskCmd1);
            addTaskCmd2 = createTask("something", TaskType.FLOATING, null, null, null);
            Task task2 = new Task(addTaskCmd2);
            addTaskCmd3 = createTask("testEvent1", TaskType.EVENT, date2, date3, null);
            Task task3 = new Task(addTaskCmd3);
            addTaskCmd4 = createTask("testEvent2", TaskType.EVENT, date2, date3, null);
            Task task4 = new Task(addTaskCmd4);
            addTaskCmd5 = createTask("testEvent3", TaskType.EVENT, date2, date3, null);
            Task task5 = new Task(addTaskCmd5);
            addTaskCmd6 = createTask("testEvent4", TaskType.EVENT, date2, date5, null);
            Task task6 = new Task(addTaskCmd6);

            testModel.addTask(task1);
            testModel.addTask(task2);
            testModel.addTask(task3);
            testModel.addTask(task4);
            testModel.addTask(task5);
            testModel.addTask(task6);

            boolean result1 = false;
            try {
                testModel.postpone(0, date6);
            } catch (Exception e) {
                result1 = true;
            }

            boolean result2 = false;
            try {
                testModel.postpone(1, date6);
            } catch (Exception e) {
                result2 = true;
            }

            testModel.postpone(2, date4);
            testModel.postpone(3, date5);
            testModel.postpone(4, date6);
            testModel.postpone(5, date7);

            boolean result3 = compareFile(testModel.getDataFilePath(), TEST_PATH_POSTPONE);

            // Clean Up
            clearExistingData(TEST_PATH);
            System.out.println("Result 1 - Normal tasks not postponed: " + result1 + " Expected: true");
            System.out.println("Result 2 - Floating tasks not postponed: " + result2 + " Expected: true");
            System.out.println(
                    "Result 3 - Multiple tasks postponed to correct dates: " + result3 + " Expected: true");
            System.out.println("=== End Test ===\n");

            assertTrue(result1);
            assertTrue(result2);
            assertTrue(result3);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }
    }

    @Test
    public void testModify() {
        try {
            clearExistingData(TEST_PATH);

            System.out.println("=== Modify ===");
            Model testModel = new Model(TEST_PATH);
            KatDateTime date1 = new KatDateTime(LocalDateTime.of(2016, 1, 26, 12, 00));
            KatDateTime date2 = new KatDateTime(LocalDateTime.of(2016, 2, 23, 23, 00));
            KatDateTime date3 = new KatDateTime(LocalDateTime.of(2016, 1, 28, 23, 00));
            KatDateTime date4 = new KatDateTime(LocalDateTime.of(2016, 1, 19, 23, 00));

            CommandDetail addTaskCmd1 = createTask("feed cat", TaskType.NORMAL, null, null, date1);
            CommandDetail addTaskCmd2 = createTask("feed fish", TaskType.EVENT, date3, date2, null);
            CommandDetail addTaskCmd3 = createTask("feed dog", TaskType.FLOATING, null, null, null);
            CommandDetail addTaskCmd4 = createTask("feed Kat!", TaskType.FLOATING, null, null, null);
            Task task1 = new Task(addTaskCmd1);
            Task task2 = new Task(addTaskCmd2);
            Task task3 = new Task(addTaskCmd3);
            Task task4 = new Task(addTaskCmd4);

            EditTaskOption option1 = new EditTaskOption(CommandProperties.TASK_TITLE, "new title");
            EditTaskOption option2 = new EditTaskOption(CommandProperties.TIME_FROM, "19/1/16 11pm");
            EditTaskOption option3 = new EditTaskOption(CommandProperties.TIME_BY, "23/2/16 11pm");
            EditTaskOption option4 = new EditTaskOption(CommandProperties.TIME_FROM, "11/3/16 3pm");

            testModel.addTask(task1);
            testModel.addTask(task2);
            testModel.addTask(task3);
            testModel.addTask(task4);
            testModel.getData().get(1).setCompleted(true);

            boolean result1 = false;
            boolean result2 = false;
            boolean result3 = true;
            boolean result4 = false;
            boolean result5 = true;
            boolean result6 = false;
            boolean result7 = true;

            // Modification
            try {
                testModel.editModify(2, option3);
                if (testModel.getData().get(2).getTaskType().equals(TaskType.NORMAL)) {
                    result1 = true;
                } else {
                    System.err
                            .println("Change in end date does not change task type from Floating to Normal.");
                }
            } catch (Exception e) {
                System.err.println("Unable to set end date for floating task.");
            }

            try {
                testModel.editModify(2, option2);
                if (testModel.getData().get(2).getTaskType().equals(TaskType.EVENT)) {
                    result2 = true;
                } else {
                    System.err
                            .println("Change in start date does not change task type from Normal to Event.");
                }
            } catch (Exception e) {
                System.err.println("Unable to set start date for normal task.");
            }

            try {
                testModel.editModify(3, option2);
                System.err
                        .println("Warning! Change in Floating to Event task type with change in start date.");
            } catch (Exception e) {
                result3 = false;
            }

            testModel.editComplete(0);
            testModel.editIncomplete(1);
            if ((testModel.getData().get(0).isCompleted()) && (!testModel.getData().get(1).isCompleted())) {
                result4 = true;
            } else {
                System.err.println("editComplete and/or editComplete not executed correctly.");
            }

            try {
                testModel.editComplete(0);
                System.err.println("Repeated setting of completed task not denied.");
            } catch (Exception e) {
                result5 = false;
            }

            testModel.editModify(0, option1);
            if (testModel.getData().get(0).getTitle().equals("new title")) {
                result6 = true;
            } else {
                System.err.println("Edit of task title not captured.");
            }

            try {
                testModel.editModify(1, option4);
                System.err.println("Setting of start date beyond end date not denied.");
            } catch (Exception e) {
                result7 = false;
            }

            // Clean Up
            clearExistingData(TEST_PATH);
            System.out.println("Result 1 - Change from Floating to Normal task by editing end date: "
                    + result1 + " Expected: true");
            System.out.println("Result 2 - Change from Normal to Event task by editing start date: " + result2
                    + " Expected: true");
            System.out.println("Result 3 - Change from Floating to Event: " + result3 + " Expected: false");
            System.out.println("Result 4 - Change in completed flag: " + result4 + " Expected: true");
            System.out
                    .println("Result 5 - Repeated change in completed flag: " + result5 + " Expected: false");
            System.out.println("Result 6 - Change in task title: " + result6 + " Expected: true");
            System.out.println(
                    "Result 7 - Change start date to beyond end date: " + result7 + " Expected: false");
            System.out.println("=== End Test ===\n");

            assertTrue(result1);
            assertTrue(result2);
            assertFalse(result3);
            assertTrue(result4);
            assertFalse(result5);
            assertTrue(result6);
            assertFalse(result7);

        } catch (Exception e) {
            System.err.println(e);
            fail("Exception!");
        }
    }
}
```
