# A0126517H
###### src\katnote\command\CommandDetail.java
``` java
package katnote.command;

import java.util.HashMap;

import katnote.parser.EditTaskOption;
import katnote.parser.ViewTaskOption;
import katnote.task.TaskType;
import katnote.utils.KatDateTime;

public class CommandDetail {
    protected CommandType commandType;
    protected HashMap<String, Object> commandData;

    /**
     * Creates new CommandDetail object of corresponding command type
     * 
     * @param commandType
     */
    public CommandDetail(CommandType commandType) {
        this.commandType = commandType;
        commandData = new HashMap<String, Object>();
    }

    /**
     * Creates new CommandDetail object with unknown command type
     */
    public CommandDetail() {
        this.commandType = CommandType.UNKNOWN;
        commandData = new HashMap<String, Object>();
    }

    /**
     * Sets the type of command
     * 
     * @param commandType
     *            New command type
     */
    public void setCommandType(CommandType commandType) {
        this.commandType = commandType;
    }

    /**
     * @return type of command
     */
    public CommandType getCommandType() {
        return commandType;
    }

    /**
     * Associates the specified value with the specified key in the properties
     * map. If the map previously contained a mapping for the key, the old value
     * is replaced.
     * 
     * @param key
     * @param value
     */
    public void setProperty(String key, Object value) {
        commandData.put(key, value);
    }

    /**
     * Returns <tt>true</tt> if this map contains a mapping for the specified
     * key.
     *
     * @param key
     *            The key whose presence in this map is to be tested
     * 
     * @return <tt>true</tt> if this map contains a mapping for the specified
     *         key.
     */
    public boolean hasProperty(String key) {
        return commandData.containsKey(key);
    }

    /**
     * Returns value of property with given key
     * 
     * @param key
     * @return the value of property with given key
     */
    public Object getProperty(String key) {
        return commandData.get(key);
    }

    /**
     * Returns value of string property with given key
     * 
     * @param key
     * @return the String value of property with given key
     */
    public String getString(String key) {
        return (String) commandData.get(key);
    }

    /**
     * Returns value of KatDateTime property with given key
     * 
     * @param key
     * @return the KatDateTime value of property with given key
     */
    public KatDateTime getDate(String key) {
        return (KatDateTime) commandData.get(key);
    }

    /**
     * Returns the EditTaskOption value of command
     * 
     * @return the EditTaskOption value of command
     */
    public EditTaskOption getEditTaskOption() {
        return (EditTaskOption) commandData.get(CommandProperties.EDIT_SET_PROPERTY);
    }

    /**
     * Returns the TASK_ID value of the task specified in commandDetail
     * 
     * @return the TASK_ID value of the task specified in commandDetail
     */
    public int getTaskIndex() {
        return (Integer) commandData.get(CommandProperties.TASK_ID);
    }

    /**
     * Returns type of tasks
     * 
     * @return type of tasks
     */
    public TaskType getTaskType() {
        return (TaskType) commandData.get(CommandProperties.TASK_TYPE);
    }

    /**
     * Returns title of task
     * 
     * @return title of task
     */
    public String getTitle() {
        return getString(CommandProperties.TASK_TITLE);
    }

    /**
     * Returns start date
     * 
     * @return start date
     */
    public KatDateTime getStartDate() {
        return getDate(CommandProperties.TIME_FROM);
    }

    /**
     * Returns end date
     * 
     * @return end date
     */
    public KatDateTime getEndDate() {
        return getDate(CommandProperties.TIME_TO);
    }

    /**
     * Returns due date
     * 
     * @return due date
     */
    public KatDateTime getDueDate() {
        return getDate(CommandProperties.TIME_BY);
    }

    /**
     * Returns keywords for command type FIND
     * 
     * @return keywords
     */
    public String getFindKeywords() {
        return getString(CommandProperties.FIND_KEYWORDS);
    }

    /**
     * Returns main content of command for command type FIND, HELP
     * 
     * @return main content of command
     */
    public String getMainContent() {
        return getString(CommandProperties.MAIN_CONTENT);
    }

    /**
     * Returns the file path property for command type IMPORT, EXPORT,
     * SET_LOCATION
     * 
     * @return the file path property
     */
    public String getFilePath() {
        return getString(CommandProperties.FILE_PATH);
    }

    /**
     * Returns task completed option for command type VIEW or EDIT_COMPLETE
     * 
     * @return task completed option
     */
    public Boolean getTaskCompletedOption() {
        return (Boolean) commandData.get(CommandProperties.TASKS_COMPLETED_OPTION);
    }

    /**
     * Returns view task option for command type VIEW
     * 
     * @return view task option
     */
    public ViewTaskOption getViewTaskOption() {
        return (ViewTaskOption) commandData.get(CommandProperties.TASKS_VIEW_OPTION);
    }

}
```
###### src\katnote\command\CommandProperties.java
``` java
package katnote.command;

public class CommandProperties {
    public static final String TASK_TITLE = "title";
    public static final String TASK_ID = "task_id";
    public static final String TASK_TYPE = "task_type";
    public static final String TASK_DESCRIPTION = "description";
    public static final String TASK_CATEGORY = "category";
    public static final String FIND_KEYWORDS = "find_keywords";
    public static final String TASKS_VIEW_OPTION = "view_tasks_option";
    public static final String TASKS_COMPLETED_OPTION = "completed_option";

    public static final String TIME_BY = "due";
    public static final String TIME_TO = "end";
    public static final String TIME_FROM = "start";
    public static final String TIME_REPEAT = "repeat";
    public static final String TIME_UNTIL = "until";

    public static final String EDIT_SET_PROPERTY = "set";
    public static final String EDIT_MARK = "edit_mark";

    public static final String LOCATION = "location";
    public static final String FILE_PATH = "file_path";
    public static final String MAIN_CONTENT = "main_content";
}
```
###### src\katnote\command\CommandType.java
``` java
package katnote.command;

public enum CommandType {
    // ADD
    ADD_TASK,

    // READ
    VIEW_TASK, VIEW_TASK_WITH_ID, FIND_TASKS,

    // UPDATE
    EDIT_MODIFY, EDIT_COMPLETE, POSTPONE,

    // DELETE
    DELETE_TASK,

    // Others
    UNDO, REDO, IMPORT, EXPORT, HELP, SET_LOCATION, EXIT,

    // Unknown or invalid command
    UNKNOWN,
}
```
###### src\katnote\parser\CommandKeywords.java
``` java
package katnote.parser;

import java.util.Arrays;
import java.util.HashSet;

public class CommandKeywords {
    // keywords for command types
    public static final String KW_ADD = "add";
    public static final String KW_ADD_SHORT = "-a";
    public static final String KW_EDIT = "edit";
    public static final String KW_EDIT_SHORT = "-e";
    public static final String KW_CHANGE = "change";
    public static final String KW_MARK = "mark";
    public static final String KW_MARK_SHORT = "-m";
    public static final String KW_POSTPONE = "postpone";
    public static final String KW_POSTPONE_SHORT = "-p";
    public static final String KW_DELETE = "delete";
    public static final String KW_DELETE_SHORT = "-d";
    public static final String KW_VIEW = "view";
    public static final String KW_VIEW_SINGLE_TASK = "view task";
    public static final String KW_VIEW_MULTIPLE_TASK = "view tasks";
    public static final String KW_VIEW_MULTIPLE_TASK_SHORT = "-v";
    public static final String KW_FIND = "find";
    public static final String KW_UNDO = "undo";
    public static final String KW_REDO = "redo";
    public static final String KW_IMPORT = "import";
    public static final String KW_EXPORT = "export";
    public static final String KW_HELP = "help";
    public static final String KW_SET_LOCATION = "set location";
    public static final String KW_EXIT = "exit";

    // keywords for command properties
    public static final String KW_SINGLE_TASK = "task";
    public static final String KW_TASKS = "tasks";
    public static final String KW_ALL = "all";
    public static final String KW_COMPLETED = "completed";
    public static final String KW_INCOMPLETED = "incompleted";

    // keywords for time properties
    public static final String KW_BY = "by";
    public static final String KW_FROM = "from";
    public static final String KW_TO = "to";
    public static final String KW_ON = "on";
    public static final String KW_AT = "at";

    // keywords for view, add properties
    public static final String KW_SET = "set";

    public static final String[] START_KEYWORDS_LIST = new String[] { KW_ADD, KW_ADD_SHORT, KW_MARK,
            KW_MARK_SHORT, KW_POSTPONE, KW_POSTPONE_SHORT, KW_EDIT, KW_EDIT_SHORT, KW_CHANGE, KW_DELETE,
            KW_DELETE_SHORT, KW_VIEW_MULTIPLE_TASK, KW_VIEW_SINGLE_TASK, KW_VIEW, KW_VIEW_MULTIPLE_TASK_SHORT,
            KW_FIND, KW_UNDO, KW_REDO, KW_IMPORT, KW_EXPORT, KW_HELP, KW_SET_LOCATION, KW_EXIT };

    private static final String[] MAIN_KEYWORDS_LIST = new String[] { KW_BY, KW_FROM, KW_TO, KW_ON, KW_AT,
            KW_SET, };

    private static final HashSet<String> MAIN_KEYWORDS_SET = new HashSet<String>(
            Arrays.asList(MAIN_KEYWORDS_LIST));

    /**
     * Checks a token whether it is a main keyword or not
     * 
     * @param token
     * @return true if token is in main keywords list, otherwise false
     */
    public static final boolean isMainKeyword(String token) {
        return MAIN_KEYWORDS_SET.contains(token.toLowerCase());
    }
}
```
###### src\katnote\parser\DateParser.java
``` java
package katnote.parser;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import katnote.utils.KatDateTime;

public class DateParser {

    private static final String STR_EMPTY = "";
    private static final String RELATIVE_TIME_TODAY = "today";
    private static final String RELATIVE_TIME_TOMORROW = "tomorrow";
    private static final String RELATIVE_TIME_NEXT_WEEK = "next week";
    private static final String RELATIVE_TIME_NEXT_MONTH = "next month";
    private static final String RELATIVE_TIME_NEXT_YEAR = "next year";
    private static final String RELATIVE_TIME_MONDAY = "monday";
    private static final String RELATIVE_TIME_TUESDAY = "tuesday";
    private static final String RELATIVE_TIME_WEDNESDAY = "wednesday";
    private static final String RELATIVE_TIME_THURSDAY = "thursday";
    private static final String RELATIVE_TIME_FRIDAY = "friday";
    private static final String RELATIVE_TIME_SATURDAY = "saturday";
    private static final String RELATIVE_TIME_SUNDAY = "sunday";
    private static final String[] MONTHS_OF_YEAR = { "january", "february", "march", "april", "may", "june",
            "july", "august", "september", "october", "november", "december" };
    private static final int MONTH_MIN_LENGTH = 3;

    // Date pattern and properties positions
    private static final String ABSOLUTE_DATE_PATTERN = "(\\d+)\\/(\\w+)(?:\\/(\\d+))?";
    private static final int ABSOLUTE_DATE_PATTERN_POS_DAY = 1;
    private static final int ABSOLUTE_DATE_PATTERN_POS_MONTH = 2;
    private static final int ABSOLUTE_DATE_PATTERN_POS_YEAR = 3;

    // Time pattern and properties positions
    private static final String ABSOLUTE_DATE_TIME_PATTERN = "(\\d{1,2})(?::(\\d+)(am|pm|)|(am|pm))";
    private static final int ABSOLUTE_DATE_TIME_PATTERN_POS_HOUR = 1;
    private static final int ABSOLUTE_DATE_TIME_PATTERN_POS_MINUTE = 2;
    private static final int ABSOLUTE_DATE_TIME_PATTERN_POS_DAY_PM = 3;
    private static final int ABSOLUTE_DATE_TIME_PATTERN_POS_DAY_PM_L = 4;

    // Special constants related to time
    private static final String DAY_PERIOD_PM = "pm";
    private static final int DAY_HALF_NUMBER_OF_HOURS = 12;
    private static final int NUMBER_OF_MONTHS = 12;
    private static final int YEAR_TWO_DIGIT_LIMIT = 100;
    private static final int YEAR_TWO_DIGIT_OFFSET = 2000;

    // default hours of day when no hour given
    public static final int MIDDLE_OF_DAY = 0;
    public static final int BEGIN_OF_DAY = 1;
    public static final int END_OF_DAY = 2;

    /**
     * Gets today Date time
     * 
     * @return the current date using the system clock and default time-zone,
     *         not null
     */
    public static LocalDate getToday() {
        return LocalDate.now();
    }

    /**
     * Gets tomorrow Date time
     * 
     * @return the date after the current date using the system clock and
     *         default time-zone, not null
     */
    public static LocalDate getTomorrow() {
        LocalDate date = LocalDate.now();
        date = date.plusDays(1);
        return date;
    }

    /**
     * Gets next week Date time
     * 
     * @return the date which is 7 days after the current date using the system
     *         clock and default time-zone, not null
     */
    public static LocalDate getNextWeek() {
        LocalDate date = LocalDate.now();
        date = date.plusWeeks(1);
        return date;
    }

    /**
     * Finds the next desired weekday
     * 
     * @param desiredWeekday
     *            the next desired weekday
     * @return the next desired weekday date after the current date using the
     *         system clock and default time-zone, not null
     */
    public static LocalDate getNextWeekDay(DayOfWeek desiredWeekday) {
        LocalDate date = LocalDate.now();
        while (true) {
            date = date.plusDays(1);
            if (date.getDayOfWeek() == desiredWeekday) {
                return date;
            }
        }
    }

    /**
     * Gets next month Date time
     * 
     * @return the date which is 1 month after the current date using the system
     *         clock and default time-zone, not null
     */
    public static LocalDate getNextMonth() {
        LocalDate date = LocalDate.now();
        date = date.plusMonths(1);
        return date;
    }

    /**
     * Gets next year Date time
     * 
     * @return the date which is 1 year after the current date using the system
     *         clock and default time-zone, not null
     */
    public static LocalDate getNextYear() {
        LocalDate date = LocalDate.now();
        date = date.plusYears(1);
        return date;
    }

    /*
     * Converts the relative time string into LocalDate object
     */
    private static LocalDate parseRelativeDate(String time) {
        switch (time.toLowerCase()) {
            case STR_EMPTY :
                return LocalDate.MIN;
            case RELATIVE_TIME_TODAY :
                return getToday();
            case RELATIVE_TIME_TOMORROW :
                return getTomorrow();
            case RELATIVE_TIME_NEXT_WEEK :
                return getNextWeek();
            case RELATIVE_TIME_NEXT_MONTH :
                return getNextMonth();
            case RELATIVE_TIME_NEXT_YEAR :
                return getNextYear();
            case RELATIVE_TIME_MONDAY :
                return getNextWeekDay(DayOfWeek.MONDAY);
            case RELATIVE_TIME_TUESDAY :
                return getNextWeekDay(DayOfWeek.TUESDAY);
            case RELATIVE_TIME_WEDNESDAY :
                return getNextWeekDay(DayOfWeek.WEDNESDAY);
            case RELATIVE_TIME_THURSDAY :
                return getNextWeekDay(DayOfWeek.THURSDAY);
            case RELATIVE_TIME_FRIDAY :
                return getNextWeekDay(DayOfWeek.FRIDAY);
            case RELATIVE_TIME_SATURDAY :
                return getNextWeekDay(DayOfWeek.SATURDAY);
            case RELATIVE_TIME_SUNDAY :
                return getNextWeekDay(DayOfWeek.SUNDAY);
        }
        return null;
    }

    private static String emptyIfNull(String s) {
        return (s == null) ? STR_EMPTY : s;
    }

    /**
     * Converts month string to number. Returns -1 if the value is invalid
     * 
     * @param monthStr
     * 
     * @return
     */
    private static int parseMonth(String monthStr) {
        monthStr = monthStr.toLowerCase();
        try {
            return Integer.parseInt(monthStr);
        } catch (NumberFormatException e) {
            if (monthStr.length() < MONTH_MIN_LENGTH) {
                return -1; // invalid months
            }
            for (int i = 0; i < NUMBER_OF_MONTHS; i++) {
                if (MONTHS_OF_YEAR[i].startsWith(monthStr)) {
                    return i + 1;
                }
            }
            return -1;
        }
    }

    /*
     * Converts string (absolute time format) to LocalDate
     */
    private static LocalDate parseAbsoluteDate(String time) {
        int currentYear = LocalDate.now().getYear();
        // matcher
        Matcher m = Pattern.compile(ABSOLUTE_DATE_PATTERN).matcher(time);
        if (m.find()) {
            int dayOfMonth = Integer.parseInt(m.group(ABSOLUTE_DATE_PATTERN_POS_DAY));
            int month = parseMonth(m.group(ABSOLUTE_DATE_PATTERN_POS_MONTH));
            int year = m.group(ABSOLUTE_DATE_PATTERN_POS_YEAR) != null
                    ? Integer.parseInt(m.group(ABSOLUTE_DATE_PATTERN_POS_YEAR)) : currentYear;

            if (year < YEAR_TWO_DIGIT_LIMIT) {
                year += YEAR_TWO_DIGIT_OFFSET;
            }

            return LocalDate.of(year, month, dayOfMonth);
        }

        return null;
    }

    /*
     * Extracts time of day from time string. If no time of day found, return
     * null instead
     */
    private static LocalTime extractTimeOfDay(String time) {
        Matcher m = Pattern.compile(ABSOLUTE_DATE_TIME_PATTERN).matcher(time);
        if (m.find()) {
            int hour = Integer.parseInt(m.group(ABSOLUTE_DATE_TIME_PATTERN_POS_HOUR));
            int minute = m.group(ABSOLUTE_DATE_TIME_PATTERN_POS_MINUTE) != null
                    ? Integer.parseInt(m.group(ABSOLUTE_DATE_TIME_PATTERN_POS_MINUTE)) : 0;
            String dayPM = emptyIfNull(m.group(ABSOLUTE_DATE_TIME_PATTERN_POS_DAY_PM))
                    + emptyIfNull(m.group(ABSOLUTE_DATE_TIME_PATTERN_POS_DAY_PM_L));
            boolean isPM = DAY_PERIOD_PM.equals(dayPM);
            if (dayPM != STR_EMPTY && hour == 12) { // special case 12am and
                                                    // 12pm
                hour = 0;
            }
            if (isPM) {
                hour = (hour + DAY_HALF_NUMBER_OF_HOURS) % 24;
            }
            return LocalTime.of(hour, minute);
        } else { // when time of day not found, return null
            return null;
        }
    }

    /*
     * Trims time of day from the string
     */
    private static String trimTimeOfDay(String time) {
        return time.replaceFirst(ABSOLUTE_DATE_TIME_PATTERN, "").trim();
    }

    /**
     * Converts string to KatDateTime object
     * 
     * @param time
     * 
     * @return New KatDateTime object representing the time string
     */
    public static KatDateTime parseDateTime(String time) {
        // get time of day and trim
        LocalTime timeOfDay = extractTimeOfDay(time);
        time = trimTimeOfDay(time);
        // check if time is relative time
        LocalDate date = parseRelativeDate(time);
        if (date != null) { // date == null means it is not relative time
            return new KatDateTime(date, timeOfDay);
        }
        // check some absolute time format
        date = parseAbsoluteDate(time);
        return new KatDateTime(date, timeOfDay);

    }

}
```
###### src\katnote\parser\EditTaskOption.java
``` java
package katnote.parser;

import katnote.utils.KatDateTime;
import katnote.utils.StringUtils;

public class EditTaskOption {
    private String taskOptionName;
    private String taskOptionValue;

    /**
     * Creates new EditTaskOption with desired option name and option value
     * 
     * @param taskOptionName
     * @param taskOptionValue
     */
    public EditTaskOption(String taskOptionName, String taskOptionValue) {
        this.taskOptionName = taskOptionName;
        this.taskOptionValue = taskOptionValue;
    }

    /**
     * Creates new EditTaskOption with the first word is option name and the
     * rest is option value
     * 
     * @param editTaskOption
     */
    public EditTaskOption(String editTaskOption) {
        taskOptionName = StringUtils.getFirstWord(editTaskOption);
        taskOptionValue = StringUtils.removeFirstWord(editTaskOption);
    }

    /**
     * Returns option name
     * 
     * @return option name
     */
    public String getOptionName() {
        return taskOptionName;
    }

    /**
     * Returns option value
     * 
     * @return option value
     */
    public String getOptionValue() {
        return taskOptionValue;
    }

    /**
     * Returns option value as an object based on the option name
     * 
     * @return New Object representing the option value
     */
    public Object getOptionValueObject() {
        return PropertyParser.parseOptionValue(taskOptionName, taskOptionValue);
    }

    /**
     * Returns option value as an KatDateTime object based on the option name
     * 
     * @return New KatDateTime object representing the option value
     */
    public KatDateTime getOptionValueDate() {
        return (KatDateTime) PropertyParser.parseOptionValue(taskOptionName, taskOptionValue);
    }
}
```
###### src\katnote\parser\Parser.java
``` java
package katnote.parser;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import katnote.KatNoteLogger;
import katnote.command.CommandDetail;
import katnote.command.CommandProperties;
import katnote.command.CommandType;
import katnote.task.TaskType;
import katnote.utils.StringUtils;

public class Parser {

    // command split pattern
    private static final String COMMAND_SPLIT_PATTERN = "(?:([^\"]\\S*)|\"(.+?)\")\\s*";
    private static final int COMMAND_SPLIT_PATTERN_NORMAL_POS = 1;
    private static final int COMMAND_SPLIT_PATTERN_QUOTED_POS = 2;

    private static final String DEFAULT_SPLIT_PATTERN = "\\s+";
    private static final String IGNORE_CASES_PATTERN = "(?i)";
    private static final String STR_EMPTY = "";
    private static final String STR_SPACE = " ";

    private static final int TOKENS_PROPERTIES_START_POS = 1;
    private static final int TOKENS_TASK_NAME_POS = 0;
    private static final int TOKENS_OPTION_POS = 0;

    // Class logger
    private static final Logger log = KatNoteLogger.getLogger(Parser.class.getName());

    /**
     * Converts the input command string into CommandDetail format containing
     * command type as well as all data field related to that type of command.
     * 
     * @param commandStr
     *            the command you want to parse
     * 
     * @return CommandDetail object containing the command type and all data
     *         fields related to that type of command
     */
    public static CommandDetail parseCommand(String commandStr) {
        log.info(String.format("Parse command: %1$s", commandStr));

        // determine command type
        StringBuilder truncatedCommand = new StringBuilder();
        String startKeyword = determineStartKeyword(commandStr, truncatedCommand);
        commandStr = truncatedCommand.toString();

        // split command
        List<String> tokens = getTokensFromCommand(commandStr);

        // parse command based on start keyword
        try {
            switch (startKeyword) {
                case CommandKeywords.KW_ADD :
                case CommandKeywords.KW_ADD_SHORT :
                    return parseAddCommand(tokens);
                case CommandKeywords.KW_VIEW_SINGLE_TASK :
                    return parseViewSingleTaskCommand(tokens);
                case CommandKeywords.KW_VIEW :
                case CommandKeywords.KW_VIEW_MULTIPLE_TASK :
                case CommandKeywords.KW_VIEW_MULTIPLE_TASK_SHORT :
                    return parseViewCommand(tokens);
                case CommandKeywords.KW_FIND :
                    return parseFindCommand(tokens);
                case CommandKeywords.KW_DELETE :
                case CommandKeywords.KW_DELETE_SHORT :
                    return parseDeleteCommand(tokens);
                case CommandKeywords.KW_MARK :
                case CommandKeywords.KW_MARK_SHORT :
                    return parseMarkCommand(tokens);
                case CommandKeywords.KW_POSTPONE :
                case CommandKeywords.KW_POSTPONE_SHORT :
                    return parsePostponeCommand(tokens);
                case CommandKeywords.KW_EDIT :
                case CommandKeywords.KW_EDIT_SHORT :
                case CommandKeywords.KW_CHANGE :
                    return parseEditCommand(tokens);
                case CommandKeywords.KW_IMPORT :
                    return parseImportCommand(tokens);
                case CommandKeywords.KW_EXPORT :
                    return parseExportCommand(tokens);
                case CommandKeywords.KW_HELP :
                    return parseHelpCommand(tokens);
                case CommandKeywords.KW_SET_LOCATION :
                    return parseSetLocationCommand(tokens);
                case CommandKeywords.KW_UNDO :
                    return new CommandDetail(CommandType.UNDO);
                case CommandKeywords.KW_REDO :
                    return new CommandDetail(CommandType.REDO);
                case CommandKeywords.KW_EXIT :
                    return new CommandDetail(CommandType.EXIT);
                default :
                    return new CommandDetail(CommandType.UNKNOWN);
            }
        } catch (Exception e) {
            return new CommandDetail(CommandType.UNKNOWN);
        }
    }

    /**
     * Determines the start keyword of the command
     * 
     * @param truncatedCommand
     *            This StringBuilder object used to store the command after
     *            truncated its start keyword
     * 
     * @return The start keyword of the command
     * 
     */
    public static String determineStartKeyword(String commandStr, StringBuilder truncatedCommand) {
        // Trim command before processing
        commandStr = commandStr.trim();
        truncatedCommand.setLength(0);
        // check different starts of command
        String lowerCaseCommandStr = commandStr.trim().toLowerCase();
        for (String startKeyword : CommandKeywords.START_KEYWORDS_LIST) {
            if (lowerCaseCommandStr.startsWith(startKeyword)) {
                truncatedCommand.append(
                        commandStr.replaceFirst(IGNORE_CASES_PATTERN + startKeyword, STR_EMPTY).trim());
                return startKeyword;
            }
        }
        // if no start found, assume the start is "add"
        truncatedCommand.append(commandStr);
        return CommandKeywords.KW_ADD;
    }

    /**
     * Splits the command string based on space but take quoted substrings as
     * one word
     * 
     * @param commandStr
     *            The command string passed from Logic
     * 
     * @return List of result tokens
     */
    public static List<String> getTokensFromCommand(String commandStr) {
        Matcher m = Pattern.compile(COMMAND_SPLIT_PATTERN).matcher(commandStr);
        List<String> tokens = new ArrayList<String>();
        StringBuilder currentToken = null;
        boolean isLastTokenKeyword = false;
        while (m.find()) {
            String token = StringUtils.concat(m.group(COMMAND_SPLIT_PATTERN_NORMAL_POS),
                    m.group(COMMAND_SPLIT_PATTERN_QUOTED_POS));
            boolean isKeyword = CommandKeywords.isMainKeyword(token);

            if (currentToken == null || isKeyword != isLastTokenKeyword) {
                if (currentToken != null) {
                    tokens.add(currentToken.toString());
                }
                currentToken = new StringBuilder(token);
            } else {
                currentToken.append(STR_SPACE + token);
            }

            isLastTokenKeyword = isKeyword;
        }
        if (currentToken != null) {
            tokens.add(currentToken.toString());
        }

        return tokens;
    }

    /*
     * Parses Add command. Command format: - add TASK_TITLE [by TIME_BY] [from
     * TIME_FROM to TIME_TO]
     * 
     * 
     */
    private static CommandDetail parseAddCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.ADD_TASK);
        String taskTitle = tokens.get(TOKENS_TASK_NAME_POS);
        command.setProperty(CommandProperties.TASK_TITLE, taskTitle);
        addCommandProperties(tokens, TOKENS_PROPERTIES_START_POS, command);
        if (command.hasProperty(CommandProperties.TIME_FROM)
                && command.hasProperty(CommandProperties.TIME_TO)) {
            command.setProperty(CommandProperties.TASK_TYPE, TaskType.EVENT);
        } else if (command.hasProperty(CommandProperties.TIME_BY)) {
            command.setProperty(CommandProperties.TASK_TYPE, TaskType.NORMAL);
        } else {
            command.setProperty(CommandProperties.TASK_TYPE, TaskType.FLOATING);
        }
        return command;
    }

    /*
     * Parses view command (single task). Command format: - view task TASK_ID
     * 
     */
    private static CommandDetail parseViewSingleTaskCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.VIEW_TASK_WITH_ID);
        // read command option
        String commandOption = tokens.get(TOKENS_OPTION_POS);
        Integer taskId = Integer.parseInt(StringUtils.getFirstWord(commandOption));
        // set properties
        command.setProperty(CommandProperties.TASK_ID, taskId);
        return command;
    }

    /*
     * Parses view command (multiple tasks). Command format: - view
     * [completed/incompleted/all] [on TIME_ON] [from TIME_FROM to TIME_TO]
     * 
     */
    private static CommandDetail parseViewCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.VIEW_TASK);
        // completed option
        int tokenStartPos = TOKENS_PROPERTIES_START_POS;
        Boolean completedOption = false;
        if (TOKENS_OPTION_POS < tokens.size()) {
            String commandOption = tokens.get(TOKENS_OPTION_POS);
            switch (commandOption) {
                case CommandKeywords.KW_COMPLETED :
                    completedOption = true;
                    break;
                case CommandKeywords.KW_INCOMPLETED :
                    completedOption = false;
                    break;
                case CommandKeywords.KW_ALL :
                    completedOption = null;
                    break;
                default :
                    completedOption = false;
                    tokenStartPos--; // when completed option is omitted
                    break;
            }
        }
        command.setProperty(CommandProperties.TASKS_COMPLETED_OPTION, completedOption);
        // add time properties
        addCommandProperties(tokens, tokenStartPos, command);
        // view task option
        ViewTaskOption viewOption = ViewTaskOption.ALL;
        if (command.hasProperty(CommandProperties.TIME_FROM)) {
            viewOption = ViewTaskOption.START_FROM;
        } else if (command.hasProperty(CommandProperties.TIME_BY)) {
            viewOption = ViewTaskOption.DUE_BY;
        }
        command.setProperty(CommandProperties.TASKS_VIEW_OPTION, viewOption);
        return command;
    }

    /*
     * Parses find command. Command format: - find KEYWORDS [in CATEGORY]
     * 
     */
    private static CommandDetail parseFindCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.FIND_TASKS);
        String keywords = tokens.get(TOKENS_TASK_NAME_POS);
        command.setProperty(CommandProperties.FIND_KEYWORDS, keywords);
        // add set or mark option
        addCommandProperties(tokens, TOKENS_PROPERTIES_START_POS, command);
        return command;
    }

    /*
     * Parses edit command. Command format: - edit TASK_ID TASK_OPTION_NAME
     * TASK_OPTION_VALUE
     * 
     */
    private static CommandDetail parseEditCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.EDIT_MODIFY);
        // read command option
        String commandOption = tokens.get(TOKENS_OPTION_POS);
        Integer taskId = Integer.parseInt(StringUtils.getFirstWord(commandOption));
        String editOption = StringUtils.removeFirstWord(commandOption);
        // set properties
        command.setProperty(CommandProperties.TASK_ID, taskId);
        command.setProperty(CommandProperties.EDIT_SET_PROPERTY, new EditTaskOption(editOption));
        return command;
    }

    /*
     * Parses mark command. Command format: - mark TASK_ID completed/incompleted
     * - mark completed/incompleted TASK_ID
     */
    private static CommandDetail parseMarkCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.EDIT_COMPLETE);
        // read command option
        String commandOptions[] = tokens.get(TOKENS_OPTION_POS).split(DEFAULT_SPLIT_PATTERN);
        Integer taskId;
        String markOption;
        if (StringUtils.isDigits(commandOptions[0])) { // mark TASK_ID completed
            taskId = Integer.valueOf(commandOptions[0]);
            markOption = commandOptions[1];
        } else { // mark completed TASK_ID
            taskId = Integer.valueOf(commandOptions[1]);
            markOption = commandOptions[0];
        }

        command.setProperty(CommandProperties.TASK_ID, taskId);
        command.setProperty(CommandProperties.TASKS_COMPLETED_OPTION,
                PropertyParser.parseOptionValue(CommandProperties.TASKS_COMPLETED_OPTION, markOption));
        command.setProperty(CommandProperties.EDIT_MARK, markOption);
        return command;
    }

    /*
     * Parses postpone command. Command format: - postpone TASK_ID
     * NEW_START_DATE
     * 
     */
    private static CommandDetail parsePostponeCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.POSTPONE);
        // read command option
        String commandOption = StringUtils.join(tokens, STR_SPACE).toLowerCase();
        Integer taskId = Integer.parseInt(StringUtils.getFirstWord(commandOption));
        String newStartDate = StringUtils.removeFirstWord(commandOption);
        // check if newStartDate starts with "to"
        if (newStartDate.startsWith(CommandKeywords.KW_TO)) {
            newStartDate = newStartDate.replaceFirst(IGNORE_CASES_PATTERN + CommandKeywords.KW_TO, STR_EMPTY)
                    .trim();
        }
        // set properties
        command.setProperty(CommandProperties.TASK_ID, taskId);
        command.setProperty(CommandProperties.TIME_FROM,
                PropertyParser.parseOptionValue(CommandProperties.TIME_FROM, newStartDate));
        return command;
    }

    /*
     * Parses delete command. Command format: - delete TASK_ID
     * 
     */
    private static CommandDetail parseDeleteCommand(List<String> tokens) throws Exception {
        CommandDetail command = new CommandDetail(CommandType.DELETE_TASK);
        // read task id
        Integer taskId = Integer.valueOf(tokens.get(TOKENS_OPTION_POS));
        command.setProperty(CommandProperties.TASK_ID, taskId);
        return command;
    }

    /*
     * Parses import command. Command format: - import FILE_PATH
     * 
     */
    private static CommandDetail parseImportCommand(List<String> tokens) {
        CommandDetail command = new CommandDetail(CommandType.IMPORT);
        String filePath = tokens.get(TOKENS_OPTION_POS);
        command.setProperty(CommandProperties.FILE_PATH, filePath);
        return command;
    }

    /*
     * Parses export command. Command format: - export FILE_PATH
     * 
     */
    private static CommandDetail parseExportCommand(List<String> tokens) {
        CommandDetail command = new CommandDetail(CommandType.EXPORT);
        String filePath = tokens.get(TOKENS_OPTION_POS);
        command.setProperty(CommandProperties.FILE_PATH, filePath);
        return command;
    }

    /*
     * Parses set save location command. Command format: - set location
     * FILE_PATH
     * 
     */
    private static CommandDetail parseSetLocationCommand(List<String> tokens) {
        CommandDetail command = new CommandDetail(CommandType.SET_LOCATION);
        String filePath = tokens.get(TOKENS_OPTION_POS);
        command.setProperty(CommandProperties.FILE_PATH, filePath);
        return command;
    }

    /*
     * Parses help command. Command format: - help - help COMMAND
     * 
     */
    private static CommandDetail parseHelpCommand(List<String> tokens) {
        CommandDetail command = new CommandDetail(CommandType.HELP);
        try {
            String filePath = tokens.get(TOKENS_OPTION_POS);
            command.setProperty(CommandProperties.MAIN_CONTENT, filePath);
        } catch (IndexOutOfBoundsException e) {
            // don't need to do nothing
        }
        return command;
    }

    /*
     * Adds command properties to command detail
     */
    private static CommandDetail addCommandProperties(List<String> tokens, int pos, CommandDetail command) {
        // add properties from tokens
        while (pos < tokens.size()) {
            String key = tokens.get(pos);
            pos++;
            String value = tokens.get(pos);
            pos++;
            PropertyParser.parseProperty(key, value, command);
        }
        // synchronize date time values
        PropertyParser.synchronizeDateTimeValues(command);
        return command;
    }

}
```
###### src\katnote\parser\PropertyParser.java
``` java
package katnote.parser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import katnote.command.CommandDetail;
import katnote.command.CommandProperties;
import katnote.command.CommandType;
import katnote.utils.DateTimeUtils;
import katnote.utils.KatDateTime;

public class PropertyParser {

    /**
     * Converts the property string value into appropriate Object based on
     * propertyName. For example, parseProperty(“from”, “24/10/2015”) will
     * return a Date object representing 24/10/2015.
     * 
     * @param propertyName
     *            Command property keyword (can be "from", "to", "by",...)
     * 
     * @param propertyValue
     *            Value of command property inputed by user input value
     * 
     * @param command
     *            the CommandDetail object which is currently working on. The
     *            result object of this property will be added as an option to
     *            this CommandDetail object
     * 
     */
    public static void parseProperty(String propertyName, String propertyValue, CommandDetail command) {
        switch (propertyName) {
            case CommandKeywords.KW_FROM :
                command.setProperty(CommandProperties.TIME_FROM,
                        parseOptionValue(CommandProperties.TIME_FROM, propertyValue));
                break;
            case CommandKeywords.KW_BY :
                command.setProperty(CommandProperties.TIME_BY,
                        parseOptionValue(CommandProperties.TIME_BY, propertyValue));
                break;
            case CommandKeywords.KW_TO :
                command.setProperty(CommandProperties.TIME_TO,
                        parseOptionValue(CommandProperties.TIME_TO, propertyValue));
                break;
            case CommandKeywords.KW_ON :
                // take the begin of day to TIME_FROM and end of day to TIME_TO
                command.setProperty(CommandProperties.TIME_FROM,
                        parseOptionValue(CommandProperties.TIME_FROM, propertyValue));
                command.setProperty(CommandProperties.TIME_TO,
                        parseOptionValue(CommandProperties.TIME_TO, propertyValue));
                break;
            case CommandKeywords.KW_SET :
                command.setProperty(CommandProperties.EDIT_SET_PROPERTY, new EditTaskOption(propertyValue));
                break;
            default :
                // unknown property, do nothing
                break;
        }
    }

    /**
     * Converts the option string value into appropriate Object based on
     * optionName.
     * 
     * @param optionName
     * @param optionValue
     * @return
     * 
     */
    public static Object parseOptionValue(String optionName, String optionValue) {
        KatDateTime date;
        switch (optionName) {
            case CommandProperties.TIME_FROM :
            case CommandProperties.TIME_BY :
            case CommandProperties.TIME_TO :
            case CommandProperties.TIME_UNTIL :
                // Date time value
                date = DateParser.parseDateTime(optionValue);
                return date;
            case CommandProperties.TASKS_COMPLETED_OPTION :
                // completed option: true, false and null (null is for both
                // completed and incompleted)
                Boolean completedValue = false;
                switch (optionValue) {
                    case CommandKeywords.KW_COMPLETED :
                        completedValue = true;
                        break;
                    case CommandKeywords.KW_INCOMPLETED :
                        completedValue = false;
                        break;
                    case CommandKeywords.KW_ALL :
                        completedValue = null;
                        break;
                }
                return completedValue;
            default :
                // String value
                return optionValue;
        }
    }

    /**
     * Automatically fills in the missing parts DateTime value of CommandDetail
     * object
     * 
     * @param command
     */
    public static void synchronizeDateTimeValues(CommandDetail command) {
        KatDateTime startDate = command.getStartDate();
        KatDateTime endDate = command.getEndDate();
        KatDateTime dueDate = command.getDueDate();
        // If command has only due date
        if (dueDate != null) {
            // if no date specified, considered it as today
            if (!dueDate.hasDate()) {
                dueDate.changeDate();
            }
            // if there is no time field, consider the time as end of day
            if (!dueDate.hasTime()) {
                dueDate.changeTime(KatDateTime.END_OF_DAY_TIME);
            }
        }
        // for command view tasks, if there is no end date, considered it as a
        // very far time,
        if (command.getCommandType() == CommandType.VIEW_TASK) {
            if (startDate != null) {
                if (endDate == null) {
                    endDate = new KatDateTime(LocalDateTime.MAX);
                    command.setProperty(CommandProperties.TIME_TO, endDate);
                }
                // also considered the due date as the end date
                command.setProperty(CommandProperties.TIME_BY, endDate);
                dueDate = endDate;
            }
        }
        // If command has startDate and endDate
        if (startDate != null && endDate != null) {
            if (!startDate.hasDate() || !endDate.hasDate()) { // at least one of
                                                              // them does not
                                                              // have date
                LocalDate laterDate = DateTimeUtils.getLater(startDate.getDate(), endDate.getDate());
                startDate.changeDate(laterDate);
                endDate.changeDate(laterDate);
            }
            // if there is no time field, consider start date as begin of day
            // and
            // end date as end of day
            if (!startDate.hasTime()) {
                startDate.changeTime(LocalTime.MIDNIGHT);
            }
            if (!endDate.hasTime()) {
                endDate.changeTime(KatDateTime.END_OF_DAY_TIME);
            }
        }
    }
}
```
###### src\katnote\parser\ViewTaskOption.java
``` java
package katnote.parser;

public enum ViewTaskOption {
    ALL, COMPLETED, INCOMPLETED, DUE_BY, START_FROM,
}
```
###### src\katnote\utils\DateTimeUtils.java
``` java
package katnote.utils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

public class DateTimeUtils {

    /**
     * Returns the later date
     * 
     * @param date1
     * @param date2
     * @return the later date among date1 and date2
     * 
     */
    public static LocalDate getLater(LocalDate date1, LocalDate date2) {
        if (date1.isAfter(date2)) {
            return date1;
        } else {
            return date2;
        }
    }

    /**
     * Returns the new date-time object with new date time value
     * 
     * @return LocalDateTime object with updated value from newDateTime
     */
    public static LocalDateTime updateDateTime(LocalDateTime datetime, KatDateTime newDateTime) {
        LocalDate date = datetime.toLocalDate();
        LocalTime time = datetime.toLocalTime();
        if (newDateTime.hasDate()) {
            date = newDateTime.getDate();
        }
        if (newDateTime.hasTime()) {
            time = newDateTime.getTime();
        }
        return LocalDateTime.of(date, time);
    }
}
```
###### src\katnote\utils\KatDateTime.java
``` java
package katnote.utils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

public class KatDateTime {

    public static final LocalTime END_OF_DAY_TIME = LocalTime.of(23, 59);

    private LocalDate _date;
    private LocalTime _time;

    /**
     * Obtains an instance of {@code KatDateTime} from a date and time.
     *
     * @param date
     *            the local date
     * @param time
     *            the local time
     * @return the date-time, not null
     */
    public KatDateTime(LocalDate date, LocalTime time) {
        _date = date;
        _time = time;
    }

    /**
     * Obtains an instance of {@code KatDateTime} from LocalDateTime
     */
    public KatDateTime(LocalDateTime datetime) {
        _date = datetime.toLocalDate();
        _time = datetime.toLocalTime();
    }

    /**
     * Converts this KatDateTime object to LocalDateTime
     **/
    public LocalDateTime toLocalDateTime() {
        if ((_date != null) && (_time != null)) {
            return LocalDateTime.of(_date, _time);
        } else {
            return null;
        }
    }

    /**
     * Gets the LocalDate part of this date-time.
     *
     * @return the date part of this date-time
     */
    public LocalDate getDate() {
        return _date;
    }

    /**
     * Gets the LocalTime part of this date-time.
     *
     * @return the time part of this date-time
     */
    public LocalTime getTime() {
        return _time;
    }

    /**
     * Returns whether this date time has date or not
     * 
     * @return true if the date part of this object is not null and not
     *         LocalDate.MIN
     */
    public boolean hasDate() {
        return _date != null && !_date.isEqual(LocalDate.MIN);
    }

    /**
     * Returns whether this date time has time or not
     * 
     * @return true if the time part of this object is not null
     */
    public boolean hasTime() {
        return _time != null;
    }

    /**
     * Updates date part of current object to today
     */
    public void changeDate() {
        _date = LocalDate.now();
    }

    /**
     * Updates date part of current object to the new date If new date is
     * LocalDate.MIN or null, considered it as today
     * 
     * @param newDate
     */
    public void changeDate(LocalDate newDate) {
        if (newDate == null || newDate.equals(LocalDate.MIN)) {
            _date = LocalDate.now();
        } else {
            _date = newDate;
        }
    }

    /**
     * Updates time part of current object to the new time
     * 
     * @param newTime
     */
    public void changeTime(LocalTime newTime) {
        _time = newTime;
    }

    /**
     * Updates time part of current object to the new date time
     * 
     * @param newDateTime
     */
    public void changeDateTime(KatDateTime newDateTime) {
        if (newDateTime.hasDate()) {
            _date = newDateTime.getDate();
        }
        if (newDateTime.hasTime()) {
            _time = newDateTime.getTime();
        }
    }

    /**
     * Outputs this date-time as a {@code String}, such as
     * {@code 2007-12-03T10:15:30}.
     * <p>
     * The output will be the same as LocalDateTime.toString()
     *
     * @return a string representation of this date-time, not null
     */
    public String toString() {
        if (hasDate()) {
            if (hasTime()) { // has both date and time
                return toLocalDateTime().toString();
            } else { // has only date
                return _date.toString();
            }
        } else { // has only time
            return _time.toString();
        }
    }
}
```
###### src\katnote\utils\StringUtils.java
``` java
package katnote.utils;

import java.util.Arrays;
import java.util.List;

public class StringUtils {

    /**
     * Gets the last word of the string
     */
    public static String getLastWord(String input) {
        String[] parts = input.trim().split("\\s+");
        String lastWord = parts[parts.length - 1];
        return lastWord;
    }

    /**
     * Trims the last word from string
     */
    public static String trimLastWord(String input) {
        List<String> parts = Arrays.asList(input.split("\\s+"));
        parts.remove(parts.size() - 1);
        return join(parts, " ");
    }

    /**
     * Removes the first word from input string For example: if input string is
     * "hello I am a programmer", the returned output is "I am a programmer"
     * 
     * @param input
     *            the input string
     * 
     * @return The resulting string
     */
    public static String removeFirstWord(String input) {
        return input.replaceFirst(getFirstWord(input), "").trim();
    }

    /**
     * Returns the first word of input string For example: if input string is
     * "hello I am a programmer", the returned output is "hello"
     * 
     * @param input
     *            the input string
     * 
     * @return The resulting string
     */
    public static String getFirstWord(String input) {
        String firstWord = input.trim().split("\\s+")[0];
        return firstWord;
    }

    /**
     * Joins string array into a string
     */
    public static String join(List<String> parts, String delim) {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (String s : parts) {
            if (!first) {
                builder.append(delim);
            } else {
                first = false;
            }
            builder.append(s);
        }
        return builder.toString();
    }

    /**
     * Concatenates string list
     */
    public static String concat(String... strings) {
        StringBuilder result = new StringBuilder();
        for (String str : strings) {
            if (str != null) {
                result.append(str);
            }
        }
        return result.toString();
    }

    /**
     * Determines if the specified string contains only digits
     * 
     */
    public static boolean isDigits(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (!Character.isDigit(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }
}
```
###### src\test\TestDateParser.java
``` java
package test;

import static org.junit.Assert.*;
import org.junit.Test;

import katnote.parser.DateParser;
import katnote.utils.KatDateTime;

public class TestDateParser {

    @Test
    public void testRelativeParser1() {
        KatDateTime date;
        date = DateParser.parseDateTime("7pm tomorrow");
        assertNotNull(date);
        System.out.println(date.toString());
    }

    // *
    @Test
    public void testAbsoluteDateParser() {
        KatDateTime date;

        // Test "7pm" (only time)
        date = DateParser.parseDateTime("7pm");
        assertNotNull(date);
        assertEquals("19:00", date.toString());

        // Test "25/10" (only date)
        date = DateParser.parseDateTime("25/10");
        assertNotNull(date);
        assertEquals("2015-10-25", date.toString());

        // Test "19/11/2015 12:00pm"
        date = DateParser.parseDateTime("19/11/2015 12:00pm");
        assertNotNull(date);
        assertEquals("2015-11-19T12:00", date.toString());

        // Test "19/Aug 19:00"
        date = DateParser.parseDateTime("19/Aug 19:00");
        assertNotNull(date);
        assertEquals("2015-08-19T19:00", date.toString());

        // Test "19/Aug 19:00"
        date = DateParser.parseDateTime("19/Aug 19:00");
        assertNotNull(date);
        assertEquals("2015-08-19T19:00", date.toString());

        // Test "25/10 9pm"
        date = DateParser.parseDateTime("25/10 9pm");
        assertNotNull(date);
        assertEquals("2015-10-25T21:00", date.toString());

        // Test "20:00 20/November"
        date = DateParser.parseDateTime("20:00 20/November");
        assertNotNull(date);
        assertEquals("2015-11-20T20:00", date.toString());

        // Test "6pm 19/Nov"
        date = DateParser.parseDateTime("6pm 19/Nov");
        assertNotNull(date);
        assertEquals("2015-11-19T18:00", date.toString());
    }
    // */

}
```
###### src\test\TestParser.java
``` java
package test;

import static org.junit.Assert.*;

import org.junit.Test;

import katnote.command.CommandDetail;
import katnote.command.CommandType;
import katnote.parser.Parser;
import katnote.parser.ViewTaskOption;

public class TestParser {

    @Test
    public void testDetermineStartKeyword() {
        StringBuilder truncatedCommand = new StringBuilder();
        String keyword = Parser.determineStartKeyword("Add hello by tuesday", truncatedCommand);
        assertEquals("add", keyword);
        assertEquals("hello by tuesday", truncatedCommand.toString());
    }

    @Test
    public void testAddCommand1() {
        CommandDetail commandDetail = Parser.parseCommand("ADD hello by tuesday");
        assertEquals(CommandType.ADD_TASK, commandDetail.getCommandType());
        assertEquals("hello", commandDetail.getTitle());
        assertNotNull(commandDetail.getDueDate());
    }

    @Test
    public void testAddCommand2() {
        CommandDetail commandDetail = Parser.parseCommand("-a hello on 29/11 8pm");
        assertEquals(CommandType.ADD_TASK, commandDetail.getCommandType());
        assertEquals("hello", commandDetail.getTitle());
        assertEquals("2015-11-29T20:00", commandDetail.getStartDate().toString());
        assertEquals("2015-11-29T20:00", commandDetail.getEndDate().toString());
    }

    @Test
    public void testAddCommand3() {
        CommandDetail commandDetail = Parser.parseCommand("hello by today");
        assertEquals(CommandType.ADD_TASK, commandDetail.getCommandType());
        assertEquals("hello", commandDetail.getTitle());
        assertNotNull(commandDetail.getDueDate());
        // System.out.println("Due Date = " +
        // commandDetail.getDueDate().toString());
    }

    @Test
    public void testAddCommand4() {
        CommandDetail commandDetail = Parser.parseCommand("hello from tomorrow 2pm to 5pm");
        assertEquals(CommandType.ADD_TASK, commandDetail.getCommandType());
        assertEquals("hello", commandDetail.getTitle());
        assertNotNull(commandDetail.getStartDate());
        assertNotNull(commandDetail.getEndDate());
        // System.out.println("Start Date = " +
        // commandDetail.getStartDate().toString());
        // System.out.println("End Date = " +
        // commandDetail.getEndDate().toString());
    }

    @Test
    public void testEditCommand1() {
        CommandDetail commandDetail = Parser.parseCommand("EDit 4 task_title hello");
        assertEquals(CommandType.EDIT_MODIFY, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        assertEquals("task_title", commandDetail.getEditTaskOption().getOptionName());
        assertEquals("hello", commandDetail.getEditTaskOption().getOptionValue());
    }

    @Test
    public void testEditCommand2() {
        CommandDetail commandDetail = Parser.parseCommand("-e 4 task_title hello");
        assertEquals(CommandType.EDIT_MODIFY, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        assertEquals("task_title", commandDetail.getEditTaskOption().getOptionName());
        assertEquals("hello", commandDetail.getEditTaskOption().getOptionValue());
    }

    @Test
    public void testMarkCommand1() {
        CommandDetail commandDetail = Parser.parseCommand("mark 4 completed");
        assertEquals(CommandType.EDIT_COMPLETE, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        // assertEquals("completed", commandDetail.getMarkOption());
    }

    @Test
    public void testMarkCommand2() {
        CommandDetail commandDetail = Parser.parseCommand("-m 4 completed");
        assertEquals(CommandType.EDIT_COMPLETE, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        // assertEquals("completed", commandDetail.getMarkOption());
    }

    @Test
    public void testPostponeCommand1() {
        CommandDetail commandDetail = Parser.parseCommand("postpone 4 5/11");
        assertEquals(CommandType.POSTPONE, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        assertEquals("2015-11-05", commandDetail.getStartDate().toString());
    }

    @Test
    public void testPostponeCommand2() {
        CommandDetail commandDetail = Parser.parseCommand("-p 4 to 5/11");
        assertEquals(CommandType.POSTPONE, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
        assertEquals("2015-11-05", commandDetail.getStartDate().toString());
    }

    @Test
    public void testDeleteCommand1() {
        CommandDetail commandDetail = Parser.parseCommand("delete 4");
        assertEquals(CommandType.DELETE_TASK, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
    }

    @Test
    public void testDeleteCommand2() {
        CommandDetail commandDetail = Parser.parseCommand("-d 4");
        assertEquals(CommandType.DELETE_TASK, commandDetail.getCommandType());
        assertEquals(4, commandDetail.getTaskIndex());
    }

    @Test
    public void testViewMultipleTasksCommand1() { // View multiple task
        CommandDetail commandDetail = Parser.parseCommand("view on monday");
        assertEquals(CommandType.VIEW_TASK, commandDetail.getCommandType());
        assertEquals(ViewTaskOption.START_FROM, commandDetail.getViewTaskOption());
        assertNotNull(commandDetail.getStartDate());
        assertNotNull(commandDetail.getEndDate());
    }

    @Test
    public void testViewMultipleTasksCommand2() { // View multiple task
        CommandDetail commandDetail = Parser.parseCommand("view tasks completed from tuesday 2pm to 5pm");
        assertEquals(CommandType.VIEW_TASK, commandDetail.getCommandType());
        assertEquals(ViewTaskOption.START_FROM, commandDetail.getViewTaskOption());
        assertNotNull(commandDetail.getStartDate());
        assertNotNull(commandDetail.getEndDate());
    }

    @Test
    public void testViewMultipleTasksCommand3() { // View multiple task
        CommandDetail commandDetail = Parser.parseCommand("-v completed by tuesday 2pm");
        assertEquals(CommandType.VIEW_TASK, commandDetail.getCommandType());
        assertEquals(ViewTaskOption.DUE_BY, commandDetail.getViewTaskOption());
        assertNull(commandDetail.getStartDate());
        assertNotNull(commandDetail.getDueDate());
    }

    @Test
    public void testViewMultipleTasksCommand4() { // View multiple task
        CommandDetail commandDetail = Parser.parseCommand("view all");
        assertEquals(CommandType.VIEW_TASK, commandDetail.getCommandType());
        assertEquals(ViewTaskOption.ALL, commandDetail.getViewTaskOption());
        assertNull(commandDetail.getStartDate());
        assertNull(commandDetail.getEndDate());
    }

    @Test
    public void testViewSingleTaskCommand1() { // View single task
        CommandDetail commandDetail = Parser.parseCommand("view task 3");
        assertEquals(CommandType.VIEW_TASK_WITH_ID, commandDetail.getCommandType());
        assertEquals(3, commandDetail.getTaskIndex());
    }

    @Test
    public void testOtherCommand() {
        // undo
        CommandDetail undoCommand = Parser.parseCommand("undo");
        assertEquals(CommandType.UNDO, undoCommand.getCommandType());
        // redo
        CommandDetail redoCommand = Parser.parseCommand("redo");
        assertEquals(CommandType.REDO, redoCommand.getCommandType());
        // help
        CommandDetail helpCommand1 = Parser.parseCommand("help");
        assertEquals(CommandType.HELP, helpCommand1.getCommandType());
        // help
        CommandDetail helpCommand2 = Parser.parseCommand("help add");
        assertEquals(CommandType.HELP, helpCommand2.getCommandType());
        assertEquals("add", helpCommand2.getMainContent());
        // import
        CommandDetail importCommand = Parser.parseCommand("import D:\blabla");
        assertEquals(CommandType.IMPORT, importCommand.getCommandType());
        assertEquals("D:\blabla", importCommand.getFilePath());
        // export
        CommandDetail exportCommand = Parser.parseCommand("export D:\blabla");
        assertEquals(CommandType.EXPORT, exportCommand.getCommandType());
        assertEquals("D:\blabla", exportCommand.getFilePath());
        // set location
        CommandDetail setLocationCommand = Parser.parseCommand("set location D:\blabla");
        assertEquals(CommandType.SET_LOCATION, setLocationCommand.getCommandType());
        assertEquals("D:\blabla", setLocationCommand.getFilePath());
    }

}
```
