# A0131003J
###### src\katnote\logic\Logic.java
``` java

/* This program contains the Logic class and its methods. Logic handles the redirection of
 * commands to the Parser and Model classes, and implements the searching/viewing commands.
 * Logic will then return a UIFeedback object after processing the command. 
 */

package katnote.logic;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.PrintWriter;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import katnote.Model;
import katnote.command.CommandDetail;
import katnote.command.CommandType;
import katnote.parser.EditTaskOption;
import katnote.parser.Parser;
import katnote.task.Task;
import katnote.task.TaskDueDateComparator;
import katnote.task.TaskStartDateComparator;
import katnote.task.TaskType;
import katnote.utils.KatDateTime;

public class Logic {

    private Model model_;
    private Tracker tracker_;
    private String sourcePathStr;

    // Error Messages
    private static final String MSG_ERR_INVALID_TYPE = "Invalid command type: %s"; // %s
                                                                                   // is
                                                                                   // the
                                                                                   // command
                                                                                   // type

    // Response Messages
    private static final String MSG_RESPONSE_SEARCH_KEYWORD = "Found %d tasks with keyword %s.";
    private static final String MSG_RESPONSE_SEARCH_DEFAULT = "Found %d tasks.";
    private static final String MSG_RESPONSE_VIEW = "Displaying %d tasks.";

    // Source Paths
    private static final String MSG_SOURCE_PATH = "sourcepath.txt";
    private static final String MSG_DEFAULT_SOURCE_PATH = "";

    /* Constructors */
    public Logic() throws Exception {
        tracker_ = new Tracker();

        // Create Model object
        File sourcePath = new File(MSG_SOURCE_PATH);
        if (!sourcePath.exists()) {
            sourcePath.createNewFile();
        }

        BufferedReader br = new BufferedReader(new FileReader(sourcePath));
        String line;
        line = br.readLine();
        if (line == null) {
            sourcePathStr = MSG_DEFAULT_SOURCE_PATH;
        } else {
            sourcePathStr = line;
        }
        br.close();

        assert(sourcePathStr != null);
        model_ = new Model(sourcePathStr);
    }

    public Logic(String path) throws Exception {
        model_ = new Model(path);
        tracker_ = new Tracker();
    }

    /* Public methods */

    /**
     * Takes in String command from GUI, parse and process the command and
     * return feedback to GUI
     * 
     * @param command
     *            String input from GUI command line interface
     * @return returns a UIFeedback object containing information for the GUI to
     *         display.
     * @throws Exception
     */
    public UIFeedback execute(String command) throws Exception {
        CommandDetail parsedTask = Parser.parseCommand(command);
        UIFeedback feedback = process(parsedTask);
        return feedback;
    }

    /**
     * Reads from Model to retrieve the default view state
     * 
     * @return viewState to be displayed when software starts up
     */
    public ViewState getInitialViewState() {
        ViewState vs = new ViewState(getDefaultViewState());
        return vs;
    }

    /**
     * For testing purpose
     */
    public ArrayList<Integer> getTrackerIDList() {
        return tracker_.getIDList();
    }

    public ArrayList<Task> getModelData() {
        return model_.getData();
    }

    public ArrayList<Task> getModelEventData() {
        return model_.getEventTasks();
    }

    /**
     * Updates tracker's ID list with the latest information based on the input
     * ArrayList of Tasks
     * 
     * @param taskList
     *            The list of tasks whose ID is to be updated to the tracker
     */
    public void setViewMapping(ArrayList<Task> taskList) {
        tracker_.setViewMapping(taskList);
    }

    /*-- Main Functions --*/

    /**
     * Reads in commandDetail obj and returns a UIFeedback obj accordingly
     * 
     * @param commandDetail
     *            commandDetail object to be processed
     * @return UIFeedback object with details after commandDetail is processed
     * @throws Exception
     */
    public UIFeedback process(CommandDetail commandDetail) throws Exception {
        CommandType type = commandDetail.getCommandType();
        UIFeedback feedback = new UIFeedback();
        int taskID; // for edit/delete commands
        int tasksFound; // number of tasks displayed for view/search commands

        switch (type) {
            case ADD_TASK :
                Task task = new Task(commandDetail);
                feedback.setResponse(model_.addTask(task));
                feedback.setViewState(getDefaultViewState());
                break;

            case EDIT_MODIFY :
                taskID = tracker_.getTaskID(commandDetail.getTaskIndex());
                EditTaskOption editOptions = commandDetail.getEditTaskOption();

                feedback.setResponse(model_.editModify(taskID, editOptions));
                feedback.setViewState(getDefaultViewState());
                break;

            case EDIT_COMPLETE :
                taskID = tracker_.getTaskID(commandDetail.getTaskIndex());
                if (commandDetail.getTaskCompletedOption()) {
                    feedback.setResponse(model_.editComplete(taskID));
                } else {
                    feedback.setResponse(model_.editIncomplete(taskID));
                }
                feedback.setViewState(getDefaultViewState());
                break;

            case POSTPONE :
                taskID = tracker_.getTaskID(commandDetail.getTaskIndex());
                feedback.setResponse(model_.postpone(taskID, commandDetail.getStartDate()));
                feedback.setViewState(getDefaultViewState());
                break;

            case DELETE_TASK :
                taskID = tracker_.getTaskID(commandDetail.getTaskIndex());
                feedback.setResponse(model_.editDelete(taskID));
                feedback.setViewState(getDefaultViewState());
                break;

            case VIEW_TASK :
                feedback.setViewState(find(commandDetail));

                tasksFound = feedback.getViewState().getViewStateSize();
                feedback.setResponse(String.format(MSG_RESPONSE_VIEW, tasksFound));

                break;

            case UNDO :
                feedback.setResponse(model_.undo());
                feedback.setViewState(getDefaultViewState());
                break;

            case REDO :
                feedback.setResponse(model_.redo());
                feedback.setViewState(getDefaultViewState());
                break;

            case FIND_TASKS :
                feedback.setViewState(find(commandDetail));
                feedback.setSearch(true);

                tasksFound = feedback.getViewState().getViewStateSize();
                String keyword = commandDetail.getFindKeywords();
                feedback.setResponse(String.format(MSG_RESPONSE_SEARCH_KEYWORD, tasksFound, keyword));

                break;

            case SET_LOCATION :
                String newSaveLocation = (String) commandDetail.getFilePath();
                feedback.setResponse(model_.setLocation(commandDetail));
                setSourcePath(newSaveLocation);
                feedback.setViewState(getDefaultViewState());
                break;

            case IMPORT :
                feedback.setResponse(model_.importData(commandDetail));
                feedback.setViewState(getDefaultViewState());
                break;

            case EXIT :
                feedback.setExit(true);
                break;

            default :
                feedback.setError(true);
                feedback.setResponse(String.format(MSG_ERR_INVALID_TYPE, type));
                feedback.setViewState(getDefaultViewState());
                break;
        }
        return feedback;
    }

    /**
     * Searches for tasks that match the specifications in the commandDetail
     * input, then returns a sorted view state.
     * 
     * @param commandDetail
     *            Contains the criteria for searching
     * @return ViewState object containing the filtered and sorted tasks.
     */

    private ViewState find(CommandDetail commandDetail) {
        Search search = new Search();
        ViewState vs = new ViewState();

        // Getting the search parameters
        Boolean isCompleted = commandDetail.getTaskCompletedOption();
        LocalDateTime dueDate = getSearchDueDateFromCommandDetail(commandDetail);
        LocalDateTime startDate = getSearchStartDateFromCommandDetail(commandDetail);
        String keyword = commandDetail.getFindKeywords();

        // Setting the search parameters
        search.setIsCompleted(isCompleted);
        search.setDue(dueDate);
        search.setStart(startDate);
        search.setKeyword(keyword);

        // search and return
        vs = getSearchedAndSortedViewState(search);
        return vs;

    }

    /*-- Helper Functions --*/

    /**
     * Searches through Model data based on the input Search object and returns
     * a searched and sorted ViewState object.
     * 
     * @param search
     *            Search object containing the information for sorting
     * @return ViewState object containing lists of tasks that are searched
     *         according to the input Search object and sorted in order of their
     *         due dates whenever possible.
     */
    private ViewState getSearchedAndSortedViewState(Search search) {

        // search
        ArrayList<Task> normal = search.searchData(model_.getNormalTasks());
        ArrayList<Task> floating = search.searchData(model_.getFloatingTasks());
        ArrayList<Task> event = search.searchData(model_.getEventTasks());

        // set
        ViewState vs = new ViewState(normal, floating, event);

        // Sort
        sortViewStateByDate(vs);

        return vs;
    }

    /**
     * Returns the processed ViewState object - filtered out tasks not within
     * the week, and completed tasks, and is sorted by date.
     * 
     * @return ViewState object with the processed data from Model.
     */
    private ViewState getDefaultViewState() {
        ViewState vs = new ViewState(model_.getNormalTasks(), model_.getFloatingTasks(),
                model_.getEventTasks());
        filterFirstWeek(vs);
        filterIncompleted(vs);
        sortViewStateByDate(vs);
        return vs;
    }

    /**
     * Gives the LocalDateTime form of the startDate search parameter from the
     * input commandDetail. null is returned if no such parameter exists. A
     * default day (today) and time (00:00) will be set in the LocalDateTime
     * object if either of the fields are not specified.
     * 
     * @param commandDetail
     *            Contains the KatDateTime object startDate, a search parameter.
     * @return The LocalDateTime object of the startDate search parameter.
     */
    private LocalDateTime getSearchStartDateFromCommandDetail(CommandDetail commandDetail) {
        LocalDateTime startDate;

        if (commandDetail.getStartDate() == null) {
            startDate = null;
        } else {
            KatDateTime katDate = commandDetail.getStartDate();

            // if time isn't specified, set a default time 00:00
            if (katDate.getTime() == null) {
                LocalDate date = katDate.getDate();
                LocalTime defaultTime = LocalTime.of(00, 00);
                startDate = LocalDateTime.of(date, defaultTime);

                // if date isn't specified, set default date today
            } else if (katDate.getDate() == null) {
                LocalDate defaultDate = LocalDate.now();
                LocalTime time = katDate.getTime();
                startDate = LocalDateTime.of(defaultDate, time);
            } else {
                startDate = commandDetail.getStartDate().toLocalDateTime();
            }
        }
        return startDate;
    }

    /**
     * Gives the LocalDateTime form of the duetDate search parameter from the
     * input commandDetail. null is returned if no such parameter exists. A
     * default day (today) and time (23:59) will be set in the returned
     * LocalDateTime object if either of the fields are not specified.
     * 
     * @param commandDetail
     *            Contains the KatDateTime object dueDate, a search parameter.
     * @return The LocalDateTime object of the dueDate search parameter.
     */
    private LocalDateTime getSearchDueDateFromCommandDetail(CommandDetail commandDetail) {
        LocalDateTime dueDate;

        if (commandDetail.getDueDate() == null) {
            dueDate = null;
        } else {
            KatDateTime katDate = commandDetail.getDueDate();

            // if time isn't specified, set a default time 23:59
            if (katDate.getTime() == null) {
                LocalDate date = katDate.getDate();
                LocalTime defaultTime = LocalTime.of(23, 59);
                dueDate = LocalDateTime.of(date, defaultTime);

                // if date isn't specified, set default date today
            } else if (katDate.getDate() == null) {
                LocalDate defaultDate = LocalDate.now();
                LocalTime time = katDate.getTime();
                dueDate = LocalDateTime.of(defaultDate, time);
            } else {
                dueDate = commandDetail.getDueDate().toLocalDateTime();
            }
        }
        return dueDate;
    }

    // TODO:
    /**
     * 
     * @param newPath
     * @throws FileNotFoundException
     */
    private void setSourcePath(String newPath) throws FileNotFoundException {

        File sourcePath = new File(MSG_SOURCE_PATH);
        PrintWriter pw = new PrintWriter(sourcePath);
        pw.println(newPath);
        pw.close();
    }

    /**
     * Sorts viewState in accordance to date. Normal tasks are sorted by their
     * due dates; Events are sorted by their start dates.
     * 
     * @param vs
     *            ViewState to be sorted.
     */
    private void sortViewStateByDate(ViewState vs) {
        ArrayList<Task> normal = vs.getNormalTasks();
        ArrayList<Task> event = vs.getEventTasks();

        vs.setNormalTasks(sortByDueDate(normal));
        vs.setEventTasks(sortByStartDate(event));
    }

    /**
     * Filters out the completed tasks in the input ViewState object
     * 
     * @param vs
     *            The ViewState object to be filtered.
     */
    private void filterIncompleted(ViewState vs) {
        assert(vs != null);

        vs.setNormalTasks(getIncompleteTasks(vs.getNormalTasks()));
        vs.setFloatingTasks(getIncompleteTasks(vs.getFloatingTasks()));
        vs.setEventTasks(getIncompleteTasks(vs.getEventTasks()));
    }

    /**
     * Filters the input ViewState object such that only the tasks within the
     * first week from today is left.
     * 
     * @param vs
     *            The ViewState object to be filtered.
     */
    private void filterFirstWeek(ViewState vs) {
        assert(vs != null);

        vs.setNormalTasks(filterFirstWeekByDueDate(vs.getNormalTasks()));
        vs.setEventTasks(filterFirstWeekByStartDate(vs.getEventTasks()));
    }

    /**
     * Returns the sorted input task list according to their due dates. Earliest
     * will come first. Time comparison precision is up till Seconds
     * 
     * @param taskList
     *            List of tasks to be sorted. Task types should be != FLOATING
     */
    private ArrayList<Task> sortByDueDate(ArrayList<Task> taskList) {
        assert(taskList != null);

        ArrayList<Task> newList = new ArrayList<Task>(taskList);
        Collections.sort(newList, new TaskDueDateComparator());
        return newList;
    }

    /**
     * Returns the sorted input task list according to their start dates.
     * Earliest will come first. Time comparison precision is up till Seconds
     * 
     * @param taskList
     *            List of tasks to be sorted. Task types should be == EVENT
     */
    private ArrayList<Task> sortByStartDate(ArrayList<Task> taskList) {
        assert(taskList != null);

        ArrayList<Task> newList = new ArrayList<Task>(taskList);
        Collections.sort(newList, new TaskStartDateComparator());
        return newList;
    }

    /**
     * Returns the input list with all completed tasks removed.
     * 
     * @param list
     *            ArrayList of Task that is to be filtered
     * @return the ArrayList of uncompleted Task
     */
    private ArrayList<Task> getIncompleteTasks(ArrayList<Task> list) {
        assert(list != null);

        ArrayList<Task> tasksFound = new ArrayList<Task>();

        for (int i = 0; i < list.size(); i++) {
            Task task = list.get(i);
            if (!task.isCompleted()) {
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

    /**
     * Filters out tasks that do not end within the week with reference to
     * current Date, and returns the list.
     * 
     * @param list
     *            ArrayList of Task that is to be filtered. TaskType == NORMAL
     */
    private ArrayList<Task> filterFirstWeekByDueDate(ArrayList<Task> list) {
        assert(list != null);

        LocalDate duedate = LocalDate.now().plusWeeks(1);
        ArrayList<Task> tasksFound = new ArrayList<Task>();

        for (int i = 0; i < list.size(); i++) {
            Task task = list.get(i);
            LocalDate taskDue = task.getEndDate().toLocalDate();
            if (!taskDue.isAfter(duedate)) {
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

    /**
     * Filters out tasks that do not start by the end of the week with reference
     * to current Date, and returns the list.
     * 
     * @param list
     *            ArrayList of Task that is to be filtered. TaskType == EVENT
     */
    private ArrayList<Task> filterFirstWeekByStartDate(ArrayList<Task> list) {
        assert(list != null);

        LocalDate startDate = LocalDate.now().plusWeeks(1);
        ArrayList<Task> tasksFound = new ArrayList<Task>();

        for (int i = 0; i < list.size(); i++) {
            Task task = list.get(i);
            LocalDate taskStart = task.getStartDate().toLocalDate();
            if (!taskStart.isAfter(startDate)) {
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

}

class Tracker {

    private static final int INDEX_OFFSET = 1;
    private ArrayList<Integer> taskIDList_; // The list of tasksIDs that is
                                            // currently displayed

    public Tracker() {
        taskIDList_ = new ArrayList<Integer>();

    }

    public ArrayList<Integer> getIDList() {
        return taskIDList_;
    }

    /**
     * @param index
     *            Task index as indicated by command input
     * @return ID of request task, -1 if index is out of bounds.
     */
    public int getTaskID(int index) {
        index -= INDEX_OFFSET;
        if (taskIDList_.size() > index) {
            return taskIDList_.get(index);
        } else {
            return -1;
        }
    }

    /**
     * Updates the taskIDList_ with the latest information based on the input
     * ArrayList of Tasks
     * 
     * @param taskList
     *            The list of tasks whose ID is to be updated to the tracker
     */
    public void setViewMapping(ArrayList<Task> taskList) {
        taskIDList_ = new ArrayList<Integer>(); // clear list

        if (!taskList.isEmpty()) {
            for (int i = 0; i < taskList.size(); i++) {
                taskIDList_.add(taskList.get(i).getID());
            }
        }
    }
}

class Search {

    private String keyword_;
    private Boolean isCompleted_; // will be set to null if searching for both

    private LocalDateTime start_; // for events only
    private LocalDateTime due_; // Includes comparison of time too

    public Search() {
    }

    public void setKeyword(String keyword) {
        keyword_ = keyword;
    }

    public void setIsCompleted(Boolean isCompleted) {
        isCompleted_ = isCompleted;
    }

    public void setStart(LocalDateTime start) {
        start_ = start;
    }

    public void setDue(LocalDateTime due) {
        due_ = due;
    }

    /* Main search method */

    public ArrayList<Task> searchData(ArrayList<Task> list) {
        ArrayList<Task> searched = new ArrayList<Task>(list);

        if (list.size() <= 0) {
            return searched;
        }

        if (keyword_ != null) {
            searched = new ArrayList<Task>(findByKeyword(searched));
        }

        if (due_ != null) {
            // System.out.println("due_ isnt null");
            searched = new ArrayList<Task>(findDueBy(searched));
        }

        if (isCompleted_ != null) {
            searched = new ArrayList<Task>(findByIsCompleted(searched));
        }

        if (start_ != null) {
            searched = new ArrayList<Task>(findStartFrom(searched));
        }

        return searched;

    }

    /* Sub Searching Methods */

    /**
     * Finds the tasks that contains the keyword (either in the task's name or
     * description) NOTE: This is case insensitive
     * 
     * @param data
     *            ArrayList of tasks to be searched
     * @param keyword
     *            String that tasks found should contain in their Name or
     *            Description fields
     * @return List of tasks that contains the input keyword
     */
    private ArrayList<Task> findByKeyword(ArrayList<Task> data) {
        ArrayList<Task> tasksFound = new ArrayList<Task>();

        for (int i = 0; i < data.size(); i++) {
            Task task = data.get(i);
            String taskTitle = task.getTitle();
            // String taskDescription = task.getDescription();

            if (isContain(taskTitle, keyword_)) { // TODO: Include comparison
                                                  // for taskDescription
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

    /**
     * Finds tasks according to the isCompleted attribute
     * 
     * @param data
     *            ArrayList of tasks to be searched
     * @return ArrayList of tasks whose isCompleted() == isCompleted_ in Search
     *         object
     */
    private ArrayList<Task> findByIsCompleted(ArrayList<Task> data) {
        ArrayList<Task> tasksFound = new ArrayList<Task>();

        for (int i = 0; i < data.size(); i++) {
            Task task = data.get(i);
            if (task.isCompleted() == isCompleted_) {
                // System.out.println(task.getTitle() + " is " + isCompleted_);
                tasksFound.add(task);
            } else {
                // System.out.println(task.getTitle() + " is NOT " +
                // isCompleted_);
            }
        }
        return tasksFound;
    }

    /**
     * Finds tasks that are due either BEFORE or BY the input date. Comparison
     * inclusive till seconds.
     * 
     * @param data
     *            ArrayList of tasks to be searched.
     * @return List of tasks with due dates/time before or equals to the input
     *         date.
     */
    private ArrayList<Task> findDueBy(ArrayList<Task> data) {
        // System.out.println("Starting findDueBy for " +
        // data.get(0).getTitle());
        ArrayList<Task> tasksFound = new ArrayList<Task>();
        LocalDateTime duedate = due_;
        LocalDateTime taskDue;

        for (int i = 0; i < data.size(); i++) {
            Task task = data.get(i);
            TaskType type = task.getTaskType();

            if (task.getEndDate() == null) {
                break;
            }

            if (type == TaskType.EVENT) {
                taskDue = task.getStartDate();
            } else {
                taskDue = task.getEndDate();
            }

            if (!taskDue.isAfter(duedate)) {
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

    /**
     * Finds tasks that starts either AFTER or ON the input date. Comparison
     * inclusive till seconds.
     * 
     * @param data
     *            ArrayList of tasks to be searched. Note TaskType == EVENT
     * @return List of tasks with start date/time after or equals to the input
     *         date
     */
    private ArrayList<Task> findStartFrom(ArrayList<Task> data) {
        // System.out.println("Starting findStartFrom");
        LocalDateTime start = start_;
        ArrayList<Task> tasksFound = new ArrayList<Task>();
        LocalDateTime taskStart;

        for (int i = 0; i < data.size(); i++) {
            Task task = data.get(i);
            TaskType type = task.getTaskType();

            if (type == TaskType.FLOATING || task.getEndDate() == null) {
                // System.out.println("Is floating task.");
                break;
            }

            if (type == TaskType.EVENT) {
                taskStart = task.getEndDate();
            } else {
                taskStart = task.getEndDate();
            }

            if (!taskStart.isBefore(start)) {
                // System.out.println(task.getTitle() + " is added");
                tasksFound.add(task);
            }
        }
        return tasksFound;
    }

    /* Helper Methods */

    // returns true if line contains exactly the input word, case insensitive
    private static boolean isContain(String line, String word) {
        if (line == null) {
            return false;
        }

        // System.out.printf("Starting isContain(%s, %s)...\n", line, word);
        String lowerCaseWord = word.toLowerCase();
        String lowerCaseLine = line.toLowerCase();

        String pattern = "\\b" + lowerCaseWord + "\\b";
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(lowerCaseLine);
        boolean ans = m.find();
        // System.out.printf("isContain(%s, %s) = %s\n", line, word, ans);
        return ans;
    }

}
```
###### src\katnote\logic\UIFeedback.java
``` java

/* This program contains the service class UIFeedback and its methods */

package katnote.logic;

public class UIFeedback {
    private boolean isError_; // true if UIFeedback contains an error
                              // reponseMessage
    private boolean isExit_;
    private boolean isSearch_;
    private ViewState viewState_;
    private String responseMessage_;

    /*-- Constructors --*/

    public UIFeedback() {
        viewState_ = new ViewState();
        isExit_ = false;
        isError_ = false;
        isSearch_ = false;
    }

    public UIFeedback(boolean isError, ViewState vs, String responseMessage) {
        isError_ = isError;
        viewState_ = vs;
        responseMessage_ = responseMessage;
        isExit_ = false;
        isSearch_ = false;
    }

    /*-- Public Methods --*/

    public void setError(boolean isError) {
        isError_ = isError;
    }

    public void setExit(boolean isExit) {
        isExit_ = isExit;
    }

    public void setSearch(boolean isSearch) {
        isSearch_ = isSearch;
    }

    public void setViewState(ViewState vs) {
        viewState_ = vs;
    }

    public void setResponse(String responseMessage) {
        responseMessage_ = responseMessage;
    }

    public boolean isAnError() {
        return isError_;
    }

    public boolean isAnExit() {
        return isExit_;
    }

    public boolean isASearch() {
        return isSearch_;
    }

    /**
     * 
     * @return Returns the ViewState attribute of UIFeedback object
     */
    public ViewState getViewState() {
        return viewState_;
    }

    /**
     * 
     * @return Returns the String containing the response message of the
     *         UIFeedback object.
     */
    public String getMessage() {
        return responseMessage_;
    }

}
```
###### src\katnote\logic\ViewState.java
``` java

/* This program contains the service class ViewState and its methods */

package katnote.logic;

import java.util.ArrayList;
import katnote.task.Task;

public class ViewState {
    private ArrayList<Task> normalTasks_;
    private ArrayList<Task> floatingTasks_;
    private ArrayList<Task> eventTasks_;

    // Constructor
    public ViewState() {
        normalTasks_ = new ArrayList<Task>();
        floatingTasks_ = new ArrayList<Task>();
        eventTasks_ = new ArrayList<Task>();
    }

    public ViewState(ViewState vs) {
        normalTasks_ = vs.getNormalTasks();
        floatingTasks_ = vs.getFloatingTasks();
        eventTasks_ = vs.getEventTasks();
    }

    public ViewState(ArrayList<Task> normalTasks, ArrayList<Task> floatingTasks, ArrayList<Task> eventTasks) {

        normalTasks_ = new ArrayList<Task>(normalTasks);
        floatingTasks_ = new ArrayList<Task>(floatingTasks);
        eventTasks_ = new ArrayList<Task>(eventTasks);
    }

    // Accessors/Getters
    public ArrayList<Task> getNormalTasks() {
        return normalTasks_;
    }

    public ArrayList<Task> getFloatingTasks() {
        return floatingTasks_;
    }

    public ArrayList<Task> getEventTasks() {
        return eventTasks_;
    }

    /**
     * 
     * @return Returns the total number of tasks found in all 3 task lists.
     */
    public int getViewStateSize() {
        int size = 0;

        if (eventTasks_ != null) {
            size += eventTasks_.size();
        }

        if (normalTasks_ != null) {
            size += normalTasks_.size();
        }

        if (floatingTasks_ != null) {
            size += floatingTasks_.size();
        }

        return size;
    }

    // Setters
    public void setNormalTasks(ArrayList<Task> list) {
        normalTasks_ = new ArrayList<Task>(list);

    }

    public void setFloatingTasks(ArrayList<Task> list) {
        floatingTasks_ = new ArrayList<Task>(list);
    }

    public void setEventTasks(ArrayList<Task> list) {
        eventTasks_ = new ArrayList<Task>(list);
    }

}
```
###### src\katnote\task\TaskDueDateComparator.java
``` java

package katnote.task;

import java.time.LocalDateTime;
import java.util.Comparator;

public class TaskDueDateComparator implements Comparator<Task> {

    public int compare(Task t1, Task t2) {
        LocalDateTime due1 = t1.getEndDate();
        LocalDateTime due2 = t2.getEndDate();

        if (due1.isAfter(due2)) {
            return 1;
        } else if (due1.isEqual(due2)) {
            return 0;
        } else {
            return -1;
        }
    }

}
```
###### src\katnote\task\TaskStartDateComparator.java
``` java

package katnote.task;

import java.time.LocalDateTime;
import java.util.Comparator;

public class TaskStartDateComparator implements Comparator<Task> {

    public int compare(Task t1, Task t2) {
        LocalDateTime due1 = t1.getStartDate();
        LocalDateTime due2 = t2.getStartDate();

        if (due1.isAfter(due2)) {
            return 1;
        } else if (due1.isEqual(due2)) {
            return 0;
        } else {
            return -1;
        }
    }

}
```
###### src\test\TestLogic.java
``` java

package test;

import static org.junit.Assert.*;

import java.io.File;
import java.util.ArrayList;

import org.junit.Test;

import katnote.logic.Logic;
import katnote.logic.UIFeedback;
import katnote.logic.ViewState;
import katnote.task.Task;
import katnote.task.TaskType;

public class TestLogic {
    private static final String TEST_SOURCE_PATH = "TestFiles/";

    private static final String INPUT_EDIT_MODIFY = "edit 1 title Feed cat";
    private static final String INPUT_MARK_COMPLETE = "mark 1 completed";
    private static final String INPUT_DELETE = "delete 1";
    private static final String INPUT_POSTPONE = "postpone 1 to 9/11/2015";
    private static final String INPUT_UNDO = "undo";
    private static final String INPUT_REDO = "redo";
    private static final String INPUT_EXIT = "exit";

    private static final String INPUT_ADD_FLOAT1 = "add float1";
    private static final String INPUT_ADD_FLOAT2 = "add float2";
    private static final String INPUT_ADD_EVENT1 = "add event1 from 8/11/2015 6pm to 13/11/2015 7pm";
    private static final String INPUT_ADD_EVENT2 = "add event2 from 8/11/2015 to 11/11/2015";
    private static final String INPUT_ADD_EVENT3 = "add event3 from 8/11/2015 to 12/11/2015";
    private static final String INPUT_ADD_EVENT4 = "add event4 from 9/11/2015 to 10/11/2015";
    private static final String INPUT_ADD_TASK1 = "task1 by 1/12/2015 6am";
    private static final String INPUT_ADD_TASK2 = "task2 by 1/12/2015";

    private static final String INPUT_VIEW_INCOMPLETED = "view incomplete";
    private static final String INPUT_VIEW_COMPLETED = "view completed";
    private static final String INPUT_VIEW = "view";

    private static final String INPUT_VIEW_ON_EXIST = "view on 8/11/2015";
    private static final String INPUT_VIEW_ON_NONEXIST = "view on 8/11/2016";

    private static final String INPUT_VIEW_BY_EXIST = "view by 1/12/2015";
    private static final String INPUT_VIEW_BY_NONEXIST = "view by 8/11/2014";
    private static final String INPUT_VIEW_FROM_TO_EXIST_NO_TIME = "view from 8/11/2015 to 1/12/2015";
    private static final String INPUT_VIEW_FROM_NONEXIST_TO_NONEXIST = "view from 8/11/2014 to 1/12/2016";
    private static final String INPUT_VIEW_FROM_TO_EXIST_NO_DATE = "view from 6pm to 7pm";

    private static final String INPUT_FIND_KEYWORD_EXIST = "find task";
    private static final String INPUT_FIND_KEYWORD_NONEXIST = "find no";
    private static final String INPUT_FIND_KEYWORD_EXIST_UPPERCASE = "find TASK1";
    private static final String INPUT_FIND_KEYWORD_EXIST_SUBSTRING = "find ta";

    private static Task float1 = new Task("float1", TaskType.FLOATING, true);
    private static Task float2 = new Task("float2", TaskType.FLOATING, false);
    private static Task event1 = new Task("event1", TaskType.EVENT, false);
    private static Task event2 = new Task("event2", TaskType.EVENT, false);
    private static Task event3 = new Task("event3", TaskType.EVENT, false);
    private static Task event4 = new Task("event4", TaskType.EVENT, false);
    private static Task task1 = new Task("task1", TaskType.NORMAL, false);
    private static Task task2 = new Task("task2", TaskType.NORMAL, false);

    /* Utility Methods */
    public boolean isEqualTask(Task t1, Task t2) {
        boolean ans = t1.getTitle().equals(t2.getTitle()) && t1.getTaskType() == t2.getTaskType();
        // System.out.println(t1.getTitle() + " " + t2.getTitle() + ": " + ans);
        return ans;
    }

    public boolean isEqualTaskList(ArrayList<Task> list1, ArrayList<Task> list2) {
        boolean ans = true;
        if (list1.isEmpty() && list2.isEmpty()) {
            ans = true;
        } else if (list2.isEmpty() && !list1.isEmpty()) {
        } else {
            for (int i = 0; i < list1.size(); i++) {
                if (!isEqualTask(list1.get(i), list2.get(i))) {
                    ans = false;
                    break;
                }
            }
        }
        return ans;
    }

    public boolean isEqualViewState(ViewState vs1, ViewState vs2) {
        return (isEqualTaskList(vs1.getNormalTasks(), vs2.getNormalTasks())
                && isEqualTaskList(vs1.getFloatingTasks(), vs2.getFloatingTasks())
                && isEqualTaskList(vs1.getEventTasks(), vs2.getEventTasks()));
    }

    public boolean isEqualUIFeedback(UIFeedback f1, UIFeedback f2) {
        boolean isVSEqual = isEqualViewState(f1.getViewState(), f2.getViewState());
        return (f1.isAnError() == f2.isAnError() && f1.isAnExit() == f2.isAnExit()
                && f1.getMessage().equals(f2.getMessage()) && isVSEqual);
    }

    private void clearExistingData(String path) {

        File clearData = new File(path + "data.txt");
        if (clearData.exists()) {
            clearData.delete();
        }
    }

    // Creates a schedule with preloaded tasks.
    private void fillSchedule(Logic logic) {
        try {
            logic.execute(INPUT_ADD_FLOAT1);
            logic.execute(INPUT_ADD_FLOAT2);
            logic.execute(INPUT_ADD_EVENT1);
            logic.execute(INPUT_ADD_EVENT2);
            logic.execute(INPUT_ADD_EVENT3);
            logic.execute(INPUT_ADD_EVENT4);
            logic.execute(INPUT_ADD_TASK1);
            logic.execute(INPUT_ADD_TASK2);
            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            logic.execute(INPUT_MARK_COMPLETE);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
    }

    /*-----------------------------------------------*/

    /* Test that command switch cases are correctly executed */
    @Test
    public void testExecuteAdd() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            UIFeedback actual = logic.execute(INPUT_ADD_FLOAT1);
            String expectedMsg = "Task: float1 added.";
            assertEquals(actual.getMessage(), expectedMsg);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteEditModify() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            UIFeedback actual = logic.execute(INPUT_EDIT_MODIFY);

            String expectedMsg = "Task: Feed cat is successfully modified.";
            assertEquals(actual.getMessage(), expectedMsg);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteEditComplete() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            UIFeedback actual = logic.execute(INPUT_MARK_COMPLETE);

            String expectedMsg = "Task: float2 is marked completed.";
            assertEquals(actual.getMessage(), expectedMsg);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteDelete() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            UIFeedback actual = logic.execute(INPUT_DELETE);

            String expectedMsg = "Task: float2 is successfully deleted.";
            assertEquals(actual.getMessage(), expectedMsg);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecutePostpone() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getEventTasks());
            UIFeedback actual = logic.execute(INPUT_POSTPONE);

            String expectedMsg = "Task: event2 is postponed to 2015-11-09T00:00";
            assertEquals(actual.getMessage(), expectedMsg);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteUndo() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            logic.execute(INPUT_MARK_COMPLETE);
            fb = logic.execute(INPUT_UNDO);

            String expectedMsg = "Mark Task: float2 undone.";
            assertEquals(fb.getMessage(), expectedMsg);
        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteRedo() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            fillSchedule(logic);

            UIFeedback fb = logic.execute(INPUT_VIEW);
            logic.setViewMapping(fb.getViewState().getFloatingTasks());
            logic.execute(INPUT_MARK_COMPLETE);
            logic.execute(INPUT_UNDO);
            fb = logic.execute(INPUT_REDO);

            String expectedMsg = "Mark Task: float2 redone.";
            assertEquals(fb.getMessage(), expectedMsg);
        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testExecuteExit() {
        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            UIFeedback actual = logic.execute(INPUT_EXIT);

            assertTrue(actual.isAnExit());

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testSetViewMapping() {
        try {
            clearExistingData(TEST_SOURCE_PATH);

            Logic logic = new Logic(TEST_SOURCE_PATH);
            Task t = new Task();
            t.setID(100); // create a new task of id = 100
            ArrayList<Task> taskList = new ArrayList<Task>();
            taskList.add(t);
            logic.setViewMapping(taskList);

            ArrayList<Integer> actual = logic.getTrackerIDList();
            ArrayList<Integer> expected = new ArrayList<Integer>();
            expected.add(100);

            clearExistingData(TEST_SOURCE_PATH);

            assertEquals(actual, expected);

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }
    }

    // Tests the view command and correctness of task sorting in ViewState
    @Test
    public void testView() {

        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            UIFeedback feedback;
            ViewState actualVS;
            ViewState expectedVS;

            fillSchedule(logic);
            // Equivalence Partition Case - View Completed Tasks
            feedback = logic.execute(INPUT_VIEW_COMPLETED);

            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getFloatingTasks().add(float1);

            System.out.println("Equivalence Partition Case - View Completed Tasks: "
                    + isEqualViewState(actualVS, expectedVS));
                    // assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View Incomplete Tasks
            feedback = logic.execute(INPUT_VIEW_INCOMPLETED);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getFloatingTasks().add(float2);

            expectedVS.getEventTasks().add(event2);
            expectedVS.getEventTasks().add(event3);
            expectedVS.getEventTasks().add(event1);
            expectedVS.getEventTasks().add(event4);
            expectedVS.getNormalTasks().add(task1);
            expectedVS.getNormalTasks().add(task2);

            System.out.println("Equivalence Partition Case - View Incomplete Tasks: "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View tasks on Date (with matches)
            feedback = logic.execute(INPUT_VIEW_ON_EXIST);

            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getEventTasks().add(event2);
            expectedVS.getEventTasks().add(event3);
            expectedVS.getEventTasks().add(event1);

            System.out.println("Equivalence Partition Case - View tasks on Date (with matches): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View tasks on Date (without matches)
            feedback = logic.execute(INPUT_VIEW_ON_NONEXIST);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - View tasks on Date (without matches): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View tasks by Date (with matches)
            feedback = logic.execute(INPUT_VIEW_BY_EXIST);

            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getNormalTasks().add(task1);
            expectedVS.getNormalTasks().add(task2);

            System.out.println("Equivalence Partition Case - View tasks by Date (with matches): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View tasks by Date (without matches)
            feedback = logic.execute(INPUT_VIEW_BY_NONEXIST);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - View tasks by Date (without matches): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition and Boundary Case - View tasks from to
            // (with matches, time not specified, and dates are at the boundary
            // of the date range of the schedule)
            feedback = logic.execute(INPUT_VIEW_FROM_TO_EXIST_NO_TIME);

            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getEventTasks().add(event2);
            expectedVS.getEventTasks().add(event3);
            expectedVS.getEventTasks().add(event1);
            expectedVS.getEventTasks().add(event4);
            expectedVS.getNormalTasks().add(task1);
            expectedVS.getNormalTasks().add(task2);

            System.out.println("Equivalence Partition and Boundary Case - View tasks from to "
                    + "(with matches, time not specified, and dates are at the boundary "
                    + "of the date range of the schedule): " + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - View tasks from to (date not
            // specified)
            feedback = logic.execute(INPUT_VIEW_FROM_TO_EXIST_NO_DATE);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - View tasks from to (date not specified): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Boundary Case - View tasks from to (using dates beyond the
            // boundary of the tasks in schedule)
            feedback = logic.execute(INPUT_VIEW_FROM_NONEXIST_TO_NONEXIST);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Boundary Case - View tasks from to "
                    + "(using dates beyond the boundary of the tasks in schedule): "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition - View Empty Schedule
            clearExistingData(TEST_SOURCE_PATH);
            logic = new Logic(TEST_SOURCE_PATH);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - View tasks from an " + "empty schedule: "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

        } catch (Exception e) {
            System.out.println(e.toString());
            fail("Exception!");
        }

        clearExistingData(TEST_SOURCE_PATH);
    }

    @Test
    public void testFind() {

        try {
            Logic logic = new Logic(TEST_SOURCE_PATH);
            UIFeedback feedback;
            ViewState actualVS;
            ViewState expectedVS;
            Task t;

            // Equivalence Partition Case - Search for task by keyword in an
            // empty list
            feedback = logic.execute(INPUT_VIEW_INCOMPLETED);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - Search in empty schedule: "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            fillSchedule(logic);

            // Search keyword that exist
            feedback = logic.execute(INPUT_FIND_KEYWORD_EXIST);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getNormalTasks().add(task1);
            expectedVS.getNormalTasks().add(task2);

            System.out.println("Equivalence Partition Case - Search keyword that exists: "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - Search keyword that doesn't exist
            feedback = logic.execute(INPUT_FIND_KEYWORD_NONEXIST);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - Search keyword that doesn't exist: "
                    + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - Search keyword that is a substring
            // of word that matches
            feedback = logic.execute(INPUT_FIND_KEYWORD_EXIST_SUBSTRING);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();

            System.out.println("Equivalence Partition Case - Search keyword that is a substring of word "
                    + "that matches: " + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

            // Equivalence Partition Case - Test the case insensitivity of
            // search function
            feedback = logic.execute(INPUT_FIND_KEYWORD_EXIST_UPPERCASE);
            actualVS = feedback.getViewState();
            expectedVS = new ViewState();
            expectedVS.getNormalTasks().add(task1);

            System.out.println("Equivalence Partition Case - Test the case insensitivity of search "
                    + "function: " + isEqualViewState(actualVS, expectedVS));
            assertTrue(isEqualViewState(actualVS, expectedVS));

        } catch (Exception e) {
            e.printStackTrace();
            fail("Exception!");
        }

        clearExistingData(TEST_SOURCE_PATH);
    }
}
```
